<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />

  <title>Manimap - Carte interactive Lille et services locaux</title>
  <meta name="description" content="Manimap est une carte interactive : trouvez des services √† Lille (restaurants, commerces, garages, pharmacies), consultez leurs horaires, avis et itin√©raires. Recherchez aussi des adresses partout dans le monde.">
  <meta name="keywords" content="manimap, carte interactive, services Lille, restaurants Lille, taxis Lille, garages Lille, pharmacies Lille, avis commerces, itin√©raires, carte mondiale">
  
  <!-- Balises pour les r√©seaux sociaux -->
  <meta property="og:title" content="Manimap | Carte Interactive des Services Locaux">
  <meta property="og:description" content="Trouvez les meilleurs services autour de vous avec la carte Manimap - restaurants, march√©s, garages, pharmacies et plus encore.">
  <meta property="og:url" content="https://cmanima.com">
  <meta property="og:type" content="website">
  
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Manimap - Carte Interactive des Services">
  <meta name="twitter:description" content="D√©couvrez et √©valuez les services locaux sur notre carte interactive. Ajoutez votre commerce gratuitement.">


  <!-- Leaflet & Plugins -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.8.0/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />

  <!-- Sitemap et robots.txt -->
  <link rel="sitemap" type="application/xml" title="Sitemap" href="/sitemap.xml">
  <link rel="canonical" href="https://cmanima.com">


  
  <meta property="og:image" content="icons/icone-manima.png">
  
  <meta name="twitter:card" content="summary_large_image">
  <!-- Remplacez l'ancien favicon par votre image -->
  <link rel="icon" type="image/png" href="icons/icone-manima.png">
  <script src="https://unpkg.com/leaflet@1.8.0/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
  <script src="https://unpkg.com/leaflet-rotatedmarker/leaflet.rotatedMarker.js"></script>
  
  <!-- REMPLACEZ Leaflet par Mapbox GL JS -->
<link href='https://api.mapbox.com/mapbox-gl-js/v2.9.2/mapbox-gl.css' rel='stylesheet' />
<script src='https://api.mapbox.com/mapbox-gl-js/v2.9.2/mapbox-gl.js'></script>
<script src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.1.0/mapbox-gl-directions.js'></script>
<link rel='stylesheet' href='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.1.0/mapbox-gl-directions.css' />

  <!-- Donn√©es structur√©es Schema.org -->

  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "Manimap",
    "description": "Carte interactive des services √† Lille avec fonctionnalit√©s d'avis et d'ajout de commerces",
    "applicationCategory": "MapApplication",
    "operatingSystem": "All",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "EUR"
    },
    "aggregateRating": {
      "@type": "AggregateRating",
      "ratingValue": "4.8",
      "reviewCount": "150"
    }
  }
  </script>

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/10.8.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.8.1/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.8.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.8.1/firebase-storage-compat.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3/dist/email.min.js"></script>
  
  <!-- Dans la section Firebase de Manimap, ajoutez Firestore -->
<script src="https://www.gstatic.com/firebasejs/10.8.1/firebase-firestore-compat.js"></script>

  <script>



    // Initialisation imm√©diate d'EmailJS
    (function() {
      emailjs.init('NgKsLCNz1k3Yxpue7');
    })();

    // ‚úÖ COLLEZ ICI - Surveillance EmailJS
    const oldEmailSend = emailjs.send;
    emailjs.send = function(...args) {
      if (window.serviceMonitor) {
        window.serviceMonitor.usage.emailSends++;
        console.log('üìß Email envoy√© - Total:', window.serviceMonitor.usage.emailSends);
      }
      return oldEmailSend.apply(this, args);
    };
  </script>
  <!-- Remplacez l'ancien import par celui-ci -->
  <script src="https://cdn.rawgit.com/davidshimjs/qrcodejs/gh-pages/qrcode.min.js"></script>

  <style>
    /* Reset global ‚Äî √† mettre tout en haut de ton CSS */
html, body {
  margin: 0 !important;
  padding: 0 !important;
  height: 100% !important;
  width: 100% !important;
  background: #fff; /* couleur de ton site */
}

/* Gestion des encoches (iPhone, Android) */
body {
  padding-top: env(safe-area-inset-top);
  padding-left: env(safe-area-inset-left);
  padding-right: env(safe-area-inset-right);
  padding-bottom: env(safe-area-inset-bottom);
}
    
    header, footer {
      text-align: center;
      padding: 10px;
      background-color: #4CAF50;
      color: white;
    }
    #map { height: calc(100vh - 160px); width: 100%; transition: transform 0.2s linear; transform-origin: center center; }
    .search-bar {
      padding: 10px;
      text-align: center;
    }
    .search-bar input {
      padding: 10px;
      font-size: 1rem;
      width: 80%;
      max-width: 400px;
      border: 2px solid #4CAF50;
      border-radius: 8px;
    }
    .modal {
      display: none;
      position: fixed;
      z-index: 9999;
      left: 0; top: 0; width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.6);
      padding-top: 50px;
    }
    .modal-content {
      background-color: #fff;
      margin: 5% auto;
      padding: 20px;
      border-radius: 15px;
      width: 90%;
      max-width: 500px;
    }
    .badge-moussaillon {
      width: 40px;  /* Augmentez cette valeur */
      height: 40px; /* Augmentez cette valeur */
      margin-left: 5px;
      vertical-align: middle;
      transition: transform 0.3s; /* Pour l'animation au survol */
    }
    .badge-moussaillon:hover {
      transform: scale(1.2); /* Effet de zoom au survol */
    }
    /* Nouveaux styles pour les chauffeurs */
    #chauffeurs-btn {
      position: fixed;
      bottom: 100px;
      right: 20px;
      background-color: #2196F3;
      color: white;
      padding: 12px 20px;
      border-radius: 30px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      z-index: 1000;
      display: none; /* Cach√© par d√©faut */
    }
    #chauffeurs-btn {
      z-index: 10000; /* Plus √©lev√© que les autres √©l√©ments */
    }

    #chauffeurs-modal {
      display: none;
      position: fixed;
      z-index: 9999;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.7);
    }

    #chauffeurs-content {
      background-color: #fff;
      margin: 5% auto;
      padding: 20px;
      border-radius: 10px;
      width: 90%;
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
    }

    .chauffeur-card {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      background-color: #f9f9f9;
    }

    .chauffeur-card h3 {
      margin-top: 0;
      color: #2196F3;
    }

    .call-btn {
      background-color: #4CAF50;
      color: white;
      padding: 8px 15px;
      border-radius: 5px;
      text-decoration: none;
      display: inline-block;
      margin-top: 10px;
    }
    /* Styles pour les avis de chauffeurs */
    .chauffeur-avis-container {
      margin-top: 15px;
      border-top: 1px dashed #ddd;
      padding-top: 15px;
    }

    .chauffeur-avis-form {
      margin-top: 10px;
    }

    .chauffeur-avis-form textarea {
      width: 100%;
      margin-bottom: 8px;
    }

    .chauffeur-avis-list {
      margin-top: 10px;
    }   

    .chauffeur-avis-item {
      padding: 8px;
      margin-bottom: 8px;
      background-color: #f0f0f0;
      border-radius: 5px;
    }

    .vote-buttons {
      display: flex;
      gap: 10px;
      margin-top: 5px;
    }

    .vote-btn {
      padding: 3px 8px;
      border-radius: 4px;
      cursor: pointer;
    }

    .vote-vert {
    }

    .vote-rouge {
    }
    /* Style pour la modal des avis */
    #tous-les-avis-modal .modal-content {
      max-height: 80vh;
      overflow-y: auto;
    }

    /* Style pour les √©l√©ments d'avis */
    .chauffeur-avis-item {
      padding: 15px;
      margin-bottom: 15px;
      border-bottom: 1px solid #eee;
      background-color: #f9f9f9;
      border-radius: 8px;
    }

    /* Style pour le bouton "Voir tous les avis" */
    .call-btn {
      /* Votre style existant */
      transition: all 0.3s;
    }

    .call-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    /* Ajoutez ceci dans votre section <style> */
    .popup-btn {
      padding: 6px 10px;
      margin: 2px 0;
      background-color: #4CAF50;
      color: white;
      border-radius: 5px;
      font-size: 0.9em;
      display: inline-block;
      width: auto;
    }

    .call-btn {
      background-color: #2196F3;
    }

    .avis-btn {
      background-color: #FF9800;
    } 
    textarea, input[type="file"], input[type="text"] {
      width: 90%; padding: 10px;
      margin-bottom: 10px;
      border: 1px solid #ccc;
      border-radius: 8px;
    }
    button {
      padding: 10px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
    }
    button:hover { background-color: #388e3c; }
   .arrow-icon {
  width: 40px;
  height: 40px;
  background: linear-gradient(145deg, #00baff, #007aff);
  clip-path: polygon(50% 0%, 70% 40%, 50% 35%, 30% 40%);
  position: relative;
  transform: rotate(0deg);
  border-radius: 50%;
  box-shadow: 0 4px 10px rgba(0, 122, 255, 0.4);
  border: 2px solid white;
}

/* Cercle central brillant */
.arrow-icon {
  width: 48px;
  height: 48px;
  background: linear-gradient(145deg, #4CAF50, #2E7D32);
  clip-path: polygon(50% 0%, 90% 100%, 50% 80%, 10% 100%);
  position: relative;
  transform: rotate(0deg);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  border: none;
  border-radius: 8px;
}

/* Pointe lumineuse en haut (effet 3D subtil) */
.arrow-icon {
  width: 48px;
  height: 48px;
  background: linear-gradient(145deg, #43A047, #2E7D32);
  clip-path: polygon(50% 0%, 90% 100%, 50% 80%, 10% 100%);
  position: relative;
  transform: rotate(0deg);
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.35);
  border: none;
  border-radius: 10px;
}
    /* Nouveaux styles pour le formulaire de commerce */
    #commerce-modal {
      display: none;
      position: fixed;
      z-index: 9999;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6);
      overflow: auto;
    }

    #commerce-modal .modal-content {
      background: linear-gradient(135deg, #f5f7fa 0%, #e4e8eb 100%);
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
      padding: 30px;
      max-width: 800px;
      max-height: 90vh;
      overflow-y: auto;
      margin: 5% auto;
      width: 90%;
    }

    #commerce-form {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      min-height: 0; /* Important pour le scroll */
    } 
    
    #commerce-form h2 {
      grid-column: 1 / -1;
      color: #2c3e50;
      text-align: center;
      margin-bottom: 20px;
      font-size: 28px;
    }
    
    .section {
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
      overflow: hidden; /* Emp√™che le contenu de d√©border */
    }
    
    .section h3 {
      color: #4CAF50;
      margin-top: 0;
      margin-bottom: 15px;
      font-size: 18px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    #commerce-form label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: #34495e;
    }
    
    #commerce-form input[type="text"],
    #commerce-form input[type="tel"],
    #commerce-form input[type="email"],
    #commerce-form input[type="url"],
    #commerce-form select,
    #commerce-form textarea {
      width: calc(100% - 30px); /* R√©duit l√©g√®rement la largeur */
      max-width: 100%;
      box-sizing: border-box; /* Inclut le padding dans la largeur */
    }
    
    #commerce-form input:focus,
    #commerce-form select:focus,
    #commerce-form textarea:focus {
      border-color: #4CAF50;
      box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.2);
      outline: none;
      background-color: white;
    }
    
    #commerce-form input[type="checkbox"] {
      margin-right: 10px;
    }
    
    #commerce-horaires-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin-bottom: 15px;
    }
    
    #commerce-horaires-container div {
      display: flex;
      flex-direction: column;
    }
    
    #commerce-horaires-container input {
      margin-bottom: 0;
    }
    
    .required::after {
      content: " *";
      color: #e74c3c;
    }
    
    /* Bouton de soumission (conserv√© comme demand√©) */
    #commerce-form button[type="submit"] {
      grid-column: 1 / -1;
      background-color: #4CAF50;
      color: white;
      padding: 15px;
      font-size: 18px;
      font-weight: bold;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      margin-top: 20px;
      transition: all 0.3s;
      width: 100%;
      max-width: 400px;
      margin-left: auto;
      margin-right: auto;
      display: block;
    }

    #commerce-form button[type="submit"]:hover {
      background-color: #388E3C;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    } 
    
    /* Responsive */
    @media (max-width: 768px) {
      #commerce-form {
        grid-template-columns: 1fr;
      }
      
      #commerce-horaires-container {
        grid-template-columns: 1fr;
      }
    }
    #ajouter-commerce-btn {
      position: fixed;
      bottom: 100px;
      right: 1200px;
      background-color: #4CAF50;
      color: white;
      padding: 12px 20px;
      border-radius: 30px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      z-index: 9999; /* Plus √©lev√© pour √™tre au-dessus de la carte */
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
    }
    /* Style pour la modal QR Code */
    #qr-modal .modal-content {
      text-align: center;
      max-width: 300px;
    }

    #qr-code-container {
      margin: 20px auto;
      padding: 10px;
      background: white;
      display: inline-block;
    }

    #qr-code-container img {
      max-width: 100%;
      height: auto;
    }

    #lien-partage {
      word-break: break-all;
      margin: 15px 0;
      padding: 10px;
      background: #f5f5f5;
      border-radius: 5px;
    }
    #streetview-embed-container {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.9);
      z-index: 10000;
    }
    #streetview-iframe {
      width: 90%; height: 90%;
      margin: 2% auto;
      display: block;
      border: none;
      border-radius: 8px;
    }
    .close-streetview {
      position: absolute;
      top: 15px; right: 15px;
      color: white;
      font-size: 24px;
      cursor: pointer;
      background: rgba(0,0,0,0.5);
      width: 40px; height: 40px;
      text-align: center;
      line-height: 40px;
      border-radius: 50%;
    }
    .leaflet-popup-content button.popup-btn {
      display: block;
      width: 100%;
      margin: 5px 0;
      padding: 8px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      text-align: center;
      cursor: pointer;
    }

    .leaflet-popup-content button.popup-btn:hover {
      background: #388E3C;
    }
    #streetview-embed-container {
      display: none;
      position: fixed;
      top: 0; 
      left: 0;
      width: 100%; 
      height: 100%;
      background: rgba(0,0,0,0.9);
      z-index: 10000;
    }

    #streetview-iframe {
      width: 90%; 
      height: 90%;
      margin: 2% auto;
      display: block;
      border: none;
      border-radius: 8px;
      background: #000;
    }

    .close-streetview {
      position: absolute;
      top: 15px; 
      right: 15px;
      color: white;
      font-size: 24px;
      cursor: pointer;
      background: rgba(0,0,0,0.5);
      width: 40px; 
      height: 40px;
      text-align: center;
      line-height: 40px;
      border-radius: 50%;
    }

    .close-streetview:hover {
      background: rgba(0,0,0,0.8);
    }
    #qr-code-container {
      margin: 20px auto;
      padding: 15px;
      background: white;
      display: inline-block;
      text-align: center;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }

    #qr-code-container div:first-child {
      font-size: 18px;
      color: #4CAF50;
      padding-bottom: 10px;
    }
    .logo-container {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 10px 0;
    }
    
    .logo {
      width: 50px;
      height: 50px;
      background-color: #4CAF50;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      position: relative;
      overflow: hidden;
    }
    
    .logo::before {
      content: "";
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0) 70%);
      transform: rotate(30deg);
    }
    
    .logo-m {
      font-size: 30px;
      font-weight: bold;
      color: white;
      font-family: 'Arial', sans-serif;
      text-shadow: 0 1px 3px rgba(0,0,0,0.3);
      transform: translateY(3px);
    }
    
    .logo-text {
      font-size: 24px;
      font-weight: bold;
      margin-left: 12px;
      color: white;
      text-transform: uppercase;
      letter-spacing: 1px;
      text-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }
    
    /* Animation au survol */
    .logo:hover {
      transform: scale(1.05);
      transition: transform 0.3s ease;
    }
    /* Structure s√©mantique */
    header, nav, main, footer {
      display: block;
    }
    
    /* Am√©lioration de l'accessibilit√© */
    :focus {
      outline: 2px solid #4CAF50;
      outline-offset: 2px;
    }
    
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      border: 0;
    }
    
    /* Navigation SEO */
    .seo-links {
      position: absolute;
      top: -40px;
      left: 0;
      background: white;
      padding: 5px;
      z-index: 10000;
      transition: top 0.3s;
    }
    
    .seo-links:focus-within {
      top: 0;
    }
    
    .seo-links a {
      margin: 0 10px;
      color: #4CAF50;
      text-decoration: none;
    }
    
    /* Contenu textuel pour SEO */
    .seo-content {
      max-width: 800px;
      margin: 20px auto;
      padding: 15px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    
    .seo-content h2 {
      color: #4CAF50;
      margin-bottom: 15px;
    }
    
    .seo-content p {
      margin-bottom: 10px;
      line-height: 1.6;
    }
    
    /* Positionnement des boutons pour mobile */
    @media (max-width: 768px) {
      #chauffeurs-btn {
        bottom: 160px;
        right: 20px;
      }
      
      #ajouter-commerce-btn {
        bottom: 90px;
        left: 20px;
        right: auto;
      }
    }
    /* Ajoutez ces styles pour les nouveaux boutons */
    .popup-btn {
      display: block;
      width: 100%;
      margin: 5px 0;
      padding: 8px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      text-align: center;
      cursor: pointer;
      font-size: 14px;
    }

    .popup-btn.call-btn {
      background-color: #2196F3;
    }

    .popup-btn:hover {
      opacity: 0.9;
    }
    /* Style pour la popup de d√©tails */
.custom-popup .leaflet-popup-content-wrapper {
  border-radius: 8px;
  max-height: 70vh;
  overflow-y: auto;
}

.custom-popup .leaflet-popup-content {
  margin: 15px;
  line-height: 1.5;
}

.details-header {
  text-align: center;
  margin-bottom: 15px;
}

.details-header h3 {
  margin: 0 0 5px 0;
  font-size: 1.3em;
  color: #2c3e50;
}

.details-header h4 {
  margin: 0;
  font-size: 1.1em;
  color: #3498db;
  font-weight: normal;
  border-bottom: 1px solid #eee;
  padding-bottom: 10px;
}

.details-content {
  font-size: 1em;
  line-height: 1.6;
}

/* Am√©lioration des sauts de ligne */
.details-content br {
  display: block;
  content: "";
  margin: 8px 0;
}
/* Ajout pour le conteneur de recommandations */
   #recommandation-container {
  position: fixed;
  bottom: 200px;
  right: 20px;
  background: white;
  border-radius: 10px;
  box-shadow: 0 4px 15px rgba(0,0,0,0.2);
  border: 2px solid #4CAF50;
  width: 280px;
  max-height: 400px;
  overflow-y: auto;
  padding: 15px;
  z-index: 1000;
  font-family: Arial, sans-serif;
}

#recommandation-title {
  font-weight: bold;
  color: #4CAF50;
  font-size: 18px;
  margin-bottom: 12px;
}

#recommandation-service ul {
  list-style: none;
  padding-left: 0;
  margin: 0;
}

#recommandation-service li {
  padding: 8px 10px;
  border-radius: 6px;
  margin-bottom: 8px;
  background: #f0f8ff;
  border-left: 4px solid #4CAF50;
  cursor: pointer;
  transition: background-color 0.3s;
}

#recommandation-service li:hover {
  background-color: #d0e8ff;
}

#recommandation-time {
  font-size: 13px;
  color: #666;
  margin-top: 10px;
  text-align: right;
}
/* Styles pour le carr√© de recommandation am√©lior√© */
    #recommandation-container {
      position: fixed;
      bottom: 150px;
      right: 20px;
      background: white;
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      border: 2px solid #4CAF50;
      width: 280px;
      max-height: 400px;
      overflow-y: auto;
      padding: 15px;
      z-index: 1000;
      font-family: Arial, sans-serif;
      transition: transform 0.3s ease;
    }
    
    #recommandation-container:hover {
      transform: translateY(-5px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.25);
    }
    
    #recommandation-title {
      font-weight: bold;
      color: #4CAF50;
      font-size: 18px;
      margin-bottom: 12px;
      border-bottom: 1px solid #e0e0e0;
      padding-bottom: 8px;
    }
    
    #recommandation-service ul {
      list-style: none;
      padding-left: 0;
      margin: 0;
    }
    
    #recommandation-service li {
      padding: 10px 12px;
      border-radius: 6px;
      margin-bottom: 8px;
      background: #f0f8ff;
      border-left: 4px solid #4CAF50;
      cursor: pointer;
      transition: all 0.3s;
      position: relative;
      overflow: hidden;
    }
    
    #recommandation-service li:hover {
      background-color: #d0e8ff;
      transform: translateX(-3px);
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    
    #recommandation-service li::after {
      content: "‚Üí";
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      color: #4CAF50;
      font-weight: bold;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    #recommandation-service li:hover::after {
      opacity: 1;
    }
    
    #recommandation-time {
      font-size: 13px;
      color: #666;
      margin-top: 10px;
      text-align: right;
      font-style: italic;
    }
    
    #close-recommandation {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      color: #777;
    }
    
    #close-recommandation:hover {
      color: #4CAF50;
    }

    /* Animation pour le chargement des recommandations */
    .loading-dots {
      display: flex;
      justify-content: center;
      padding: 15px 0;
    }
    
    .dot {
      width: 8px;
      height: 8px;
      background-color: #4CAF50;
      border-radius: 50%;
      margin: 0 4px;
      animation: pulse 1.5s infinite ease-in-out;
    }
    
    .dot:nth-child(1) { animation-delay: 0s; }
    .dot:nth-child(2) { animation-delay: 0.5s; }
    .dot:nth-child(3) { animation-delay: 1s; }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 0.7; }
      50% { transform: scale(1.3); opacity: 1; }
    }
    /* Style suppl√©mentaire pour le titre du march√© */
    .market-day {
      color: #e74c3c;
      font-weight: bold;
      font-style: italic;
      margin-top: 5px;
    }
    #recommandation-market-day {
  color: #e74c3c;
  font-weight: bold;
  font-style: italic;
  margin-top: 5px;
  display: none; /* cach√© par d√©faut */
}
/* Style pour le conteneur des march√©s */
  #market-container {
    position: fixed;
    bottom: 20px;
    right: 320px;
    background: white;
    border-radius: 10px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    border: 2px solid #e74c3c;
    width: 250px;
    padding: 15px;
    z-index: 1000;
    font-family: Arial, sans-serif;
    transition: transform 0.3s ease;
  }

  #market-container:hover {
    transform: translateY(-5px);
    box-shadow: 0 6px 20px rgba(0,0,0,0.25);
  }

  #market-title {
    font-weight: bold;
    color: #e74c3c;
    font-size: 18px;
    margin-bottom: 10px;
    text-align: center;
    border-bottom: 1px solid #e0e0e0;
    padding-bottom: 8px;
  }

  #market-service ul {
    list-style: none;
    padding-left: 0;
    margin: 0;
  }

  #market-service li {
    padding: 10px 12px;
    border-radius: 6px;
    margin-bottom: 8px;
    background: #fdf2f2;
    border-left: 4px solid #e74c3c;
    cursor: pointer;
    transition: all 0.3s;
    position: relative;
    overflow: hidden;
  }

  #market-service li:hover {
    background-color: #f8d7da;
    transform: scale(1.05); /* Effet de grossissement au survol */
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    z-index: 1;
  }

  #market-service li::after {
    content: "‚Üí";
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    color: #e74c3c;
    font-weight: bold;
    opacity: 0;
    transition: opacity 0.3s;
  }

  #market-service li:hover::after {
    opacity: 1;
  }

/* Ajoutez ce style √† la fin de votre CSS existant */
.warning-banner {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background-color: #fff3cd;
  color: #856404;
  padding: 12px 20px;
  text-align: center;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  z-index: 10000;
  border-bottom: 1px solid #ffeeba;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: transform 0.3s ease;
}

.warning-banner.hidden {
  transform: translateY(-100%);
  opacity: 0;
  pointer-events: none;
  visibility: hidden;
}

.warning-banner p {
  margin: 0;
  font-size: 14px;
  line-height: 1.5;
}

.close-btn {
  background: none;
  border: none;
  color: #856404;
  font-size: 20px;
  cursor: pointer;
  margin-left: 15px;
  padding: 5px;
}
/*mosquee*/
#jumua-container {
    display: none;
    position: fixed;
    bottom: 100px;
    right: 20px;
    background: white;
    border-radius: 10px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    border: 2px solid #4CAF50;
    width: 250px;
    padding: 15px;
    z-index: 1000;
    font-family: Arial, sans-serif;
    transition: transform 0.3s ease;
  }

  #jumua-container:hover {
    transform: translateY(-5px);
    box-shadow: 0 6px 20px rgba(0,0,0,0.25);
  }

  #jumua-title {
    font-weight: bold;
    color: #4CAF50;
    font-size: 18px;
    margin-bottom: 12px;
    border-bottom: 1px solid #e0e0e0;
    padding-bottom: 8px;
  }

  #jumua-service ul {
    list-style: none;
    padding-left: 0;
    margin: 0;
  }

  #jumua-service li {
    padding: 10px 12px;
    border-radius: 6px;
    margin-bottom: 8px;
    background: #f0f8ff;
    border-left: 4px solid #4CAF50;
    cursor: pointer;
    transition: all 0.3s;
    position: relative;
    overflow: hidden;
  }

  #jumua-service li:hover {
    background-color: #d0e8ff;
    transform: scale(1.05); /* Effet de grossissement au survol */
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    z-index: 1;
  }

  #jumua-service li::after {
    content: "‚Üí";
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    color: #4CAF50;
    font-weight: bold;
    opacity: 0;
    transition: opacity 0.3s;
  }

  #jumua-service li:hover::after {
    opacity: 1;
  }
  /* Responsive mobile */
@media (max-width: 768px) {

  /* Carte */
  #map {
    height: calc(100vh - 120px);
  }

  /* Bouton Ajouter Commerce : petit, bas √† droite */
  #ajouter-commerce-btn {
    bottom: 10px;
    right: 1px;
    left: 20px !important;
    padding: 6px 7px;
    font-size: 13px;
    min-width: 59px;    /* largeur minimale pour rester cliquable */
    min-height: 20px;   /* hauteur minimale pour rester cliquable */
  }

  /* Bouton Chauffeurs */
  #chauffeurs-btn {
    bottom: 70px;
    right: 1px;
    padding: 8px 12px;
    font-size: 13px;
    z-index: 1;
  }

  #recommandation-container,
#market-container,
#jumua-container {
  width: 190px;
  height: 90px;
  left: 10px;       /* coll√© √† gauche */
  padding: 5px;
  position: fixed;
  overflow-y: auto;
  box-sizing: border-box;
  right: auto;
}

/* Empilement vertical bien propre */
#market-container         { bottom: 20px; }   /* tout en bas */
#recommandation-container { bottom: 20px; }  /* juste au-dessus de market */
#jumua-container          { bottom: 220px; }  /* au-dessus de recommendation */*/

  /* Modales */
  .modal-content {
    width: 95%;
    margin: 5% auto;
    padding: 15px;
    max-height: 85vh;
    overflow-y: auto;
  }

  #contenu-avis {
    max-height: 50vh;
  }

  /* Avis sur mobile */
  .chauffeur-avis-item {
    padding: 10px;
    margin-bottom: 10px;
  }

  /* Formulaires */
  textarea, input[type="file"], input[type="text"] {
    width: 95%;
    padding: 8px;
  }

  /* Barre de recherche */
  .search-bar input {
    width: 90%;
    padding: 8px;
    font-size: 0.9rem;
  }

  /* Boutons popup */
  .popup-btn {
    padding: 6px 8px;
    font-size: 12px;
    margin: 3px 0;
  }
}
/* R√®gles par d√©faut pour tous les √©crans (grand √©cran compris) */
#itineraire-infos {
    bottom: 400px !important; /* Augmenter de 450px √† 480px pour le remonter */
    left: 10px !important;
    padding: 8px !important;
    font-size: 14px !important;
    max-width: 200px !important;
    }
#market-container {
  position: fixed !important;
  bottom: 150px !important;
  left: 20px !important;  /* coll√© √† gauche */
  width: 250px !important;
  padding: 15px !important;
  background: white !important;
  border-radius: 10px !important;
  border: 2px solid #e74c3c !important;
  box-shadow: 0 4px 15px rgba(0,0,0,0.2) !important;
  z-index: 1000 !important;
  transition: transform 0.3s ease !important;
  overflow-y: auto !important;
}
#ajouter-commerce-btn {
  position: fixed !important;   /* n√©cessaire pour le coller √† l'√©cran */
  bottom: 100px !important;
  left: 20px !important;        /* coll√© √† gauche */
  right: auto !important;       /* on d√©sactive le "right" */
  padding: 14px 5px !important;
  font-size: 13px !important;
  min-width: unset !important;   /* supprime la largeur minimale */
  max-width: unset !important;
  border-radius: 19px !important;
}

#recommandation-container {
  position: fixed !important;
  bottom: 150px !important;
  right: 20px !important;
  width: 280px !important;
  padding: 15px !important;
  background: white !important;
  border-radius: 10px !important;
  border: 2px solid #4CAF50 !important;
  box-shadow: 0 4px 15px rgba(0,0,0,0.2) !important;
  z-index: 1000 !important;
  transition: transform 0.3s ease !important;
  overflow-y: auto !important;
}

#jumua-container {
  position: fixed !important;
  bottom: 150px !important;
  left: 20px !important;
  width: 250px !important;
  padding: 15px !important;
  background: white !important;
  border-radius: 10px !important;
  border: 2px solid #4CAF50 !important;
  box-shadow: 0 4px 15px rgba(0,0,0,0.2) !important;
  z-index: 1000 !important;
  transition: transform 0.3s ease !important;
  overflow-y: auto !important;
}

#chauffeurs-btn {
  position: fixed !important;
  bottom: 100px !important;
  right: 20px !important;
  padding: 12px 20px !important;
  font-size: 14px !important;
  z-index: 1000 !important;
}

/* Media query pour les √©crans <= 768px (mobiles) */
@media (max-width: 768px) {
   #itineraire-infos {
    bottom: 500px !important; /* Augmenter de 450px √† 480px pour le remonter */
    left: 10px !important;
    padding: 8px !important;
    font-size: 14px !important;
    max-width: 200px !important;
  }
  #market-container, #recommandation-container, #jumua-container {
    left: 10px !important;
    right: auto !important;
    width: 190px !important;
    height: 100px !important;
    padding: 5px !important;
  }

  #market-container { bottom: 125px !important; }
  #recommandation-container { bottom: 15px !important; }
  #jumua-container { bottom: 125px !important; }

  #chauffeurs-btn {
    bottom: 60px !important;
    right: 1px !important;
    left: auto !important;
    padding: 8px 12px !important;
    font-size: 13px !important;
  }
  #ajouter-commerce-btn {
  position: fixed !important;
  bottom: 10px !important;
  right: 1px !important;
  left: auto !important;
  padding: 14px 2px !important;
  font-size: 13px !important;
  border-radius: 19px !important; /* arrondi sympa */
  width: auto !important;        /* largeur auto comme chauffeur */
  min-width: unset !important;   /* supprime la largeur minimale */
  max-width: unset !important;   /* supprime la largeur maximale */
}
  
}

/* Tr√®s petits √©crans */
@media (max-width: 480px) {
  header h1 { font-size: 1.5rem; }
  footer p { font-size: 0.8rem; }
  .modal-content { padding: 10px; }
  .modal-content h2 { font-size: 1.2rem; }
  button { padding: 8px; font-size: 0.9rem; }
}

@media (max-width: 480px) {
  #itineraire-infos {
    bottom: 500px !important; /* Encore plus haut sur tr√®s petits √©crans */
    max-width: 180px !important;
    font-size: 12px !important;
  }
}

/* Exp√©rience tactile */
@media (hover: none) and (pointer: coarse) {
  .popup-btn, button { min-height: 44px; min-width: 44px; }
  #recommandation-service li { padding: 12px 15px; }
}

/* ‚úÖ Version mobile du banner d'avertissement*/
@media (max-width: 600px) {
  .warning-banner {
    position: fixed;
    top: 170px;              /* distance depuis le haut */
    left: 50%;               /* centrage horizontal */
    transform: translateX(-50%);
    width: 280px;            /* largeur du rectangle */
    height: 175px;        
    padding: 10px 15px;
    font-size: 13px;
    border-radius: 10px;
    background-color: #fff3cd;
    color: #856404;
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    z-index: 10000;
    overflow: visible;       /* le texte ne sera pas coup√© */
  }

  .warning-banner p {
  margin-top: 20px;  /* espace suppl√©mentaire au-dessus du texte */
  margin-bottom: 0;
  line-height: 1.4;
  word-break: break-word;
}

  .close-btn {
    font-size: 14px;
    margin-top: 5px;
  }
}

/*correction mobile*/
  /* Supprimer l'espace blanc en haut sur mobile */
/* Bouton Stop Itin√©raire */
#stop-itineraire-btn {
  position: fixed;
  bottom: 20px; /* Distance du bas */
  left: 50%; /* Centre horizontal */
  transform: translateX(-50%); /* Corrige le centrage */
  background-color: #ff4444;
  color: white;
  padding: 12px 24px;
  border-radius: 30px;
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  z-index: 1000;
  display: none; /* Cach√© par d√©faut */
  cursor: pointer;
  font-weight: bold;
  font-size: 16px;
  text-align: center;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

#stop-itineraire-btn:hover {
  transform: translateX(-50%) scale(1.05);
  box-shadow: 0 6px 12px rgba(0,0,0,0.25);
}

#stop-itineraire-btn:hover {
  background-color: #cc0000;
}

/* Am√©lioration des popups pour √©viter les collisions */
.leaflet-popup {
    pointer-events: auto !important;
}

.leaflet-popup-content-wrapper {
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.15);
    max-height: 70vh;
    overflow-y: auto;
}

.leaflet-popup-content {
    margin: 15px;
    line-height: 1.5;
}

/* Espacement entre les popups */
.leaflet-marker-icon {
    z-index: 1000;
}

.leaflet-popup {
    z-index: 2000;
}

/*hgzzedkuyhjvazd*/
/* CORRECTION DU SCROLL DANS LES AVIS */
#liste-avis-modal .modal-content {
  max-height: 80vh;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
}

#contenu-avis {
  max-height: 60vh;
  overflow-y: auto;
  padding: 10px;
  margin-top: 15px;
  border: 1px solid #eee;
  border-radius: 8px;
  background: #f9f9f9;
}

/* Am√©lioration du scroll sur mobile */
@media (max-width: 768px) {
  #liste-avis-modal .modal-content {
    max-height: 90vh;
    margin: 2% auto;
  }
  
  #contenu-avis {
    max-height: 70vh;
  }
}

/* Style am√©lior√© pour les √©l√©ments d'avis */
.avis-item {
  padding: 15px;
  margin-bottom: 15px;
  border-bottom: 1px solid #eee;
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.avis-item:last-child {
  margin-bottom: 0;
  border-bottom: none;
}
/* Am√©liorations pour le QR Code */
#qr-modal .modal-content {
  max-width: 320px;
  margin: 5% auto;
  padding: 20px;
}

#qr-code-container {
  margin: 15px auto;
  padding: 15px;
  background: white;
  border-radius: 12px;
  display: inline-block;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  border: 2px solid #4CAF50;
}

#qr-code-container canvas {
  max-width: 100%;
  height: auto;
  border-radius: 8px;
}

/* Boutons am√©lior√©s */
#qr-modal button {
  padding: 12px 20px;
  margin: 8px 5px;
  background: #4CAF50;
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  font-weight: bold;
  transition: all 0.3s;
  min-height: 44px;
}

#qr-modal button:hover {
  background: #388E3C;
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

/* Mobile */
@media (max-width: 768px) {
  #qr-modal .modal-content {
    max-width: 90vw;
    margin: 10% auto;
    padding: 15px;
  }
  
  #qr-modal button {
    width: 100%;
    margin: 5px 0;
  }
}

/* Modal Classement Snacks */
#snack-ranking-modal {
  display: none;
  position: fixed;
  z-index: 999;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0,0,0,0.7);
}

#snack-ranking-content {
  background-color: #fff;
  margin: 5% auto;
  padding: 20px;
  border-radius: 15px;
  width: 90%;
  max-width: 600px;
  max-height: 80vh;
  overflow-y: auto;
  box-shadow: 0 10px 30px rgba(0,0,0,0.3);
}

/* Bouton Classement */
#snack-ranking-btn {
  position: fixed;
  bottom: 20px;
  right: 20px;
  background: #d32f2f;
  color: white;
  border: none;
  border-radius: 50px;
  padding: 15px 30px;
  font-size: 16px;
  font-weight: bold;
  cursor: pointer;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  z-index: 998;
  transition: all 0.3s ease;
}

#snack-ranking-btn:hover {
  background: #b71c1c;
  transform: scale(1.05);
}

/* Styles pour la liste de classement */
.snack-ranking-item {
  display: flex;
  align-items: center;
  padding: 15px;
  margin-bottom: 10px;
  background: #f8f9fa;
  border-radius: 10px;
  border-left: 4px solid #ff4444;
  transition: all 0.3s ease;
  cursor: pointer;
}

.snack-ranking-item:hover {
  background: #e9ecef;
  transform: translateX(5px);
}

.ranking-position {
  font-size: 24px;
  font-weight: bold;
  color: #ff4444;
  min-width: 40px;
  text-align: center;
}

.snack-info {
  flex: 1;
}

.snack-name {
  font-weight: bold;
  font-size: 16px;
  color: #333;
  margin-bottom: 5px;
}

.snack-details {
  font-size: 12px;
  color: #666;
}

.snack-score {
  background: #ff4444;
  color: white;
  padding: 5px 10px;
  border-radius: 20px;
  font-weight: bold;
  font-size: 14px;
}

/* Responsive */
@media (max-width: 768px) {
  #snack-ranking-btn {
    bottom: 90px;
    right: 20px;
    left: auto;
    top: auto;
    max-width: 150px; /* R√©duit la largeur maximale */
    padding: 12px 15px; /* R√©duit le padding horizontal (15px au lieu de 30px) */
  }
  
  #snack-ranking-content {
    margin: 10% auto;
    width: 95%;
    padding: 5px;
  }
  
  .snack-ranking-item {
    padding: 12px;
  }
  
  .ranking-position {
    font-size: 20px;
    min-width: 35px;
  }
  
  .snack-name {
    font-size: 14px;
  }
  
  .snack-score {
    font-size: 12px;
    padding: 4px 8px;
  }
}
  </style>
</head>
<body>
  <!-- Bouton Classement Snacks -->
<button id="snack-ranking-btn" onclick="afficherClassementSnacks()">üèÜ Classement Food Clash</button>

<!-- Modal Classement Snacks -->
<div id="snack-ranking-modal" class="modal">
  <div id="snack-ranking-content">
    <span class="close-btn" onclick="fermerClassementSnacks()">&times;</span>
    <h2 style="text-align: center; color: #ff4444; margin-bottom: 20px;">üèÜ Classement des restos et snacks </h2>
    <div id="snack-ranking-list">
      <!-- La liste sera g√©n√©r√©e dynamiquement -->
    </div>
    <div style="text-align: center; margin-top: 20px; color: #666; font-size: 12px;">
      Cliquez sur un endroit pour le localiser sur la carte
    </div>
  </div>
</div>


  <!-- Navigation cach√©e pour SEO -->
  <nav class="seo-links" aria-label="Liens rapides">
    <a href="#services-lille">Services √† Lille</a>
    <a href="#ajouter-commerce">Ajouter un commerce</a>
    <a href="#chauffeurs-lille">Chauffeurs Lille</a>
    <a href="#carte-interactive">Carte interactive</a>
  </nav>
  <header><h1>Manimap</h1></header>

  <div class="search-bar">
    <input type="text" id="search-bar" placeholder="Rechercher un service (garage, h√¥pital, etc.)">
  </div>

  <div id="map"></div>

  <!-- Bouton Chauffeurs (visible seulement pour les Commandants) -->
  <button id="chauffeurs-btn" onclick="afficherChauffeurs()">üöñ Nos Chauffeurs</button>
  <!-- Bouton Ajouter Commerce (visible pour tous) -->
  <button id="ajouter-commerce-btn" onclick="afficherFormulaireCommerce()">‚ûï Ajouter mon  commerce</button>
  <!-- Modal des Chauffeurs -->
  <div id="chauffeurs-modal" class="modal">
    <div id="chauffeurs-content">
      <span class="close-btn" onclick="fermerChauffeurs()">&times;</span>
      <h2>Nos Chauffeurs Partenaires</h2>
      <div id="liste-chauffeurs"></div>
    </div>
  </div>
  
  <!-- Ajoutez cette div juste apr√®s l'ouverture du <body> -->
  <div id="warningBanner" class="warning-banner">
    <p>
      <strong>Nos services sont pour l‚Äôinstant disponibles uniquement √† Lille.</strong>
      Si vous √™tes en dehors de cette zone, il est normal qu‚Äôaucun service n‚Äôapparaisse autour de vous. Vous √™tes commer√ßant, restaurateur ou professionnel ? Ajoutez gratuitement votre service sur la carte et rendez-le visible aupr√®s de nos utilisateurs !
    </p>
    <button class="close-btn" onclick="hideWarning()">√ó</button>
  </div>

  <!-- Modals -->
  <div id="avis-modal" class="modal">
    <div class="modal-content">
      <span class="close-btn" onclick="fermerModal()">&times;</span>
      <h2 id="titre-avis">Soumettre un avis</h2>
      <form id="avis-form">
        <input type="text" id="pseudo-avis" placeholder="Votre pseudo" disabled />
        <textarea id="text-avis" placeholder="Votre avis..." required></textarea>
        <label for="photo-avis" style="display: block; margin-bottom: 5px; font-weight: bold;">Photo (optionnel)</label>
        <input type="file" id="photo-avis" accept="image/*" />

        <label for="video-avis" style="display: block; margin-top: 10px; margin-bottom: 5px; font-weight: bold;">Vid√©o (optionnel)</label>
        <input type="file" id="video-avis" accept="video/*" />
        <button type="submit">Envoyer</button>
      </form>
    </div>
  </div>

  <div id="liste-avis-modal" class="modal">
    <div class="modal-content">
      <span class="close-btn" onclick="fermerListeAvis()">&times;</span>
      <h2 id="titre-liste-avis">Avis</h2>
      <div id="contenu-avis"></div>
    </div>
  </div>
  
 <!-- Correction du conteneur de recommandations -->
<div id="recommandation-container">
  <div id="recommandation-title">Recommandations du moment</div>
  <div id="recommandation-market-day"></div>
  <div id="recommandation-service"></div>
  <div id="recommandation-time"></div>
</div>

<!-- Ajoutez ceci apr√®s votre conteneur de recommandations existant -->
<div id="market-container" style="display: none; position: fixed; bottom: 390px; right: 20px; background: white; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); border: 2px solid #e74c3c; width: 250px; padding: 15px; z-index: 1000; font-family: Arial, sans-serif;">
  <div id="market-title" style="font-weight: bold; color: #e74c3c; font-size: 18px; margin-bottom: 10px; text-align: center;"></div>
  <div id="market-service"></div>
</div>

<!-- Ajoutez ceci apr√®s le conteneur de march√© -->
<div id="jumua-container" style="display: none; position: fixed; bottom: 150px; right: 1110px; background: white; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); border: 2px solid #4CAF50; width: 250px; padding: 15px; z-index: 1000; font-family: Arial, sans-serif;">
  <div id="jumua-title" style="font-weight: bold; color: #4CAF50; font-size: 18px; margin-bottom: 10px; text-align: center;">Jumua</div>
  <div id="jumua-service"></div>
</div>

  <!-- Modal Ajout Commerce -->
<div id="commerce-modal" class="modal">
    <div class="modal-content">
      <span class="close-btn" onclick="fermerCommerceModal()">&times;</span>
      <h2>Ajouter mon commerce</h2>
      <form id="commerce-form">
        <!-- Section Infos de base -->
        <div class="section">
          <h3><span>üè™</span> Infos de base sur le commerce</h3>
          <label for="commerce-nom" class="required">Nom du commerce</label>
          <input type="text" id="commerce-nom" required placeholder="Ex: Boulangerie du Centre">
          
          <label for="commerce-categorie" class="required">Cat√©gorie</label>
          <select id="commerce-categorie" required>
            <option value="">-- S√©lectionnez --</option>
            <option value="boulangerie">Boulangerie</option>
            <option value="coiffeur">Coiffeur</option>
            <option value="garage">Garage</option>
            <option value="restaurant">Restaurant</option>
            <option value="pharmacie">Pharmacie</option>
            <option value="supermarche">Super march√©</option>
            <option value="autre">Autre</option>
          </select>
          
          <label for="commerce-description" class="required">Description courte (max 300 caract√®res)</label>
          <textarea id="commerce-description" maxlength="300" required placeholder="D√©crivez bri√®vement votre commerce..."></textarea>
        </div>
        
        <!-- Section Localisation -->
        <div class="section">
          <h3><span>üìç</span> Localisation pr√©cise</h3>
          <label for="commerce-adresse" class="required">Adresse compl√®te</label>
          <input type="text" id="commerce-adresse" required placeholder="Ex: 123 Rue Principale">
          
          <label for="commerce-ville" class="required">Ville</label>
          <input type="text" id="commerce-ville" required placeholder="Ex: Lille">
          
          <label for="commerce-codepostal" class="required">Code postal</label>
          <input type="text" id="commerce-codepostal" required placeholder="Ex: 59000">
          
          <div style="margin-top: 15px;">
            <label>
              <input type="checkbox" id="commerce-geoloc-auto"> 
              <span style="font-weight: normal;">G√©olocalisation automatique</span>
            </label>
            <small style="display: block; margin-top: 5px; color: #7f8c8d;">Cochez pour trouver automatiquement les coordonn√©es GPS</small>
          </div>
        </div>
        
        <!-- Section Horaires -->
        <div class="section">
          <h3><span>üïí</span> Horaires d'ouverture</h3>
          <div id="commerce-horaires-container"></div>
          <div style="margin-top: 15px;">
            <label>
              <input type="checkbox" id="commerce-ouvert-7j7"> 
              <span style="font-weight: normal;">Ouvert 7j/7</span>
            </label>
          </div>
          <div style="margin-top: 10px;">
            <label>
              <input type="checkbox" id="commerce-sur-rdv"> 
              <span style="font-weight: normal;">Sur RDV uniquement</span>
            </label>
          </div>
        </div>
        
        <!-- Section Contact -->
        <div class="section">
          <h3><span>‚òéÔ∏è</span> Contact</h3>
          <label for="commerce-telephone" class="required">Num√©ro de t√©l√©phone</label>
          <input type="tel" id="commerce-telephone" required placeholder="Ex: 0612345678">
          
          <label for="commerce-email">Adresse email</label>
          <input type="email" id="commerce-email" placeholder="Ex: contact@commerce.com">
          
          <label for="commerce-whatsapp">Lien WhatsApp</label>
          <input type="url" id="commerce-whatsapp" placeholder="Ex: https://wa.me/33612345678">
        </div>
        
        <!-- Section Identit√© -->
        <div class="section">
          <h3><span>‚úçÔ∏è</span> Identit√© du d√©posant</h3>
          <label for="commerce-nom-gerant" class="required">Nom complet du g√©rant/responsable</label>
          <input type="text" id="commerce-nom-gerant" required placeholder="Ex: Jean Dupont">
          
          <label for="commerce-email-gerant" class="required">Email de contact</label>
          <input type="email" id="commerce-email-gerant" required placeholder="Ex: gerant@commerce.com">
          
          <div style="margin-top: 15px;">
            <label>
              <input type="checkbox" id="commerce-cgu" required> 
              <span style="font-weight: normal;">
                J'accepte les <a href="/cgu.html">Conditions G√©n√©rales d‚ÄôUtilisation</a> et je confirme que ces informations sont exactes
              </span>
            </label>
          </div>
        </div>
        
        <button type="submit">Soumettre mon commerce</button>
        <!-- Bouton Stop Itin√©raire -->
        

      </form>
    </div>
  </div>
  <div id="streetview-embed-container">
    <iframe id="streetview-iframe" allowfullscreen></iframe>
    <div class="close-streetview" onclick="fermerStreetView()">√ó</div>
  </div>
  <div id="streetview-embed-container" style="display:none;position:fixed;top:0;left:0; width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:10000;">
    <!-- Le contenu sera inject√© par JavaScript -->
  </div>
  <button id="stop-itineraire-btn" onclick="arreterItineraire()">‚èπÔ∏è Stop Itin√©raire</button>
  <footer><p>&copy; 2025 Manimap‚Ñ¢ - Tous droits r√©serv√©s</p></footer>
  <script>

    // Ajoutez cet objet de mapping des mots-cl√©s au d√©but de votre script, apr√®s les constantes
    const keywordToTypes = {
  'pompe essence': ['pompe','station-service', 'station essence', 'carburant', 'total', 'esso', 'leclerc station', 'fuel', 'gas', 'gasoline', 'petrol'],
  'pompe a essence': ['pompe','station-service', 'station essence', 'carburant', 'fuel', 'gas', 'gasoline', 'petrol'],
  'station service': ['station essence', 'station-service', 'carburant', 'fuel station', 'gas station', 'petrol station'],
  'station essence': ['station-service', 'pompe essence', 'carburant', 'total', 'esso', 'leclerc station', 'fuel', 'gas', 'gasoline', 'petrol'],
  'essence': ['station-service', 'pompe essence', 'carburant', 'fuel', 'gas', 'gasoline', 'petrol'],
  'fuel': ['essence', 'carburant', 'pompe essence', 'station-service', 'station essence', 'gas station', 'petrol'],
  'gas': ['essence', 'carburant', 'pompe essence', 'station-service', 'station essence', 'fuel', 'gasoline', 'petrol'],
  'gasoline': ['essence', 'carburant', 'pompe essence', 'station-service', 'station essence', 'fuel', 'petrol'],
  'petrol': ['essence', 'carburant', 'pompe essence', 'station-service', 'station essence', 'fuel', 'gasoline'],

  'restaurant': ['restaurant', 'fast food', 'caf√©', 'bar', 'bistrot', 'resto', 'snack', 'food', 'eatery', 'dining'],
  'nourriture': ['boulangerie', 'supermarch√©', '√©picerie', 'market', 'alimentation', 'food', 'grocery', 'supermarket'],
  'sant√©': ['pharmacie', 'h√¥pital', 'clinique', 'm√©decin', 'dentiste', 'health', 'hospital', 'clinic', 'doctor', 'pharmacy'],
  'transport': ['metro','m√©tro','transport', 'station-service', 'taxi', 'vtc', 'bus', 'tram', 'train', 'transportation', 'public transport'],
  'metro': ['transport', 'station-service', 'taxi', 'vtc', 'bus', 'tram', 'train', 'subway', 'underground'],
  'shopping': ['magasin', 'centre commercial', 'boutique', 'commerce', 'shop', 'mall', 'store'],
  'loisirs': ['cin√©ma', 'mus√©e', 'parc', 'jardin', 'zoo', 'attraction', 'leisure', 'entertainment', 'park', 'museum'],
  '√©ducation': ['√©cole', 'universit√©', 'biblioth√®que', '√©cole de conduite', 'education', 'school', 'university', 'library'],
  'h√©bergement': ['h√¥tel', 'motel', 'auberge', 'chambre d‚Äôh√¥te', 'hotel', 'hostel', 'lodging', 'bnb'],
  'religion': ['mosqu√©e', '√©glise', 'temple', 'lieu de culte', 'church', 'mosque', 'temple', 'religion', 'worship'],
  'urgence': ['police', 'pompiers', 'urgences', 'h√¥pital urgence', 'emergency', 'hospital emergency', 'firefighters', 'police station']
};
    const firebaseConfig = {
      apiKey: "AIzaSyAid2_e5G6nk7_rAgn_G2M9gMYpGv9TyVc",
      authDomain: "manima-7e23a.firebaseapp.com",
      databaseURL: "https://manima-7e23a-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "manima-7e23a",
      storageBucket: "manima-7e23a.appspot.com",
      messagingSenderId: "135877962056",
      appId: "1:135877962056:web:06da5bcc6901a352ccab7d"
    };
    // 2. NOUVEAU CODE - √©couteur de recherche
    document.addEventListener('DOMContentLoaded', function() {
        const searchBar = document.getElementById('search-bar');
        searchBar.addEventListener('input', function(e) {
            const filtre = e.target.value.trim();
            console.log("Recherche:", filtre);
            afficherServices(filtre);
        });
    });
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    // SYSTEME DE MONITORING GRATUIT
    class ServiceMonitor {
      constructor() {
        this.usage = {
          firebaseReads: 0,
          firebaseWrites: 0,
          mapboxCalls: 0,
          emailSends: 0,
          weatherCalls: 0
        };
        
        this.limits = {
          firebaseReads: 50000,     // 50K/jour
          firebaseWrites: 20000,    // 20K/jour  
          mapboxCalls: 1667,        // 50K/mois √∑ 30
          emailSends: 6,            // 200/mois √∑ 30
          weatherCalls: 33          // 1K/mois √∑ 30
        };
        
        this.startMonitoring();
      }
      
      startMonitoring() {
        // Surveiller Firebase
        this.monitorFirebase();
        
        // Surveiller Mapbox
        this.monitorMapbox();
        
        // Alertes quotidiennes
        setInterval(() => this.dailyReport(), 24 * 60 * 60 * 1000);
        
        // V√©rification toutes les heures
        setInterval(() => this.checkLimits(), 60 * 60 * 1000);
      }
      
      monitorFirebase() {
        const oldRef = firebase.database.Reference.prototype.set;
        firebase.database.Reference.prototype.set = function(...args) {
          window.serviceMonitor.usage.firebaseWrites++;
          return oldRef.apply(this, args);
        };
        
        const oldOn = firebase.database.Reference.prototype.on;
        firebase.database.Reference.prototype.on = function(...args) {
          window.serviceMonitor.usage.firebaseReads++;
          return oldOn.apply(this, args);
        };
      }
      
      monitorMapbox() {
        const oldFlyTo = L.Map.prototype.flyTo;
        L.Map.prototype.flyTo = function(...args) {
          window.serviceMonitor.usage.mapboxCalls++;
          return oldFlyTo.apply(this, args);
        };
      }
      
      checkLimits() {
        const warnings = [];
        
        if (this.usage.firebaseReads > this.limits.firebaseReads * 0.8) {
          warnings.push(`üö® Firebase: ${this.usage.firebaseReads}/50K lectures`);
        }
        
        if (this.usage.firebaseWrites > this.limits.firebaseWrites * 0.8) {
          warnings.push(`üö® Firebase: ${this.usage.firebaseWrites}/20K √©critures`);
        }
        
        if (this.usage.mapboxCalls > this.limits.mapboxCalls * 0.8) {
          warnings.push(`üö® Mapbox: ${this.usage.mapboxCalls}/1,667 appels`);
        }
        
        if (this.usage.emailSends > this.limits.emailSends * 0.8) {
          warnings.push(`üö® EmailJS: ${this.usage.emailSends}/6 emails`);
        }
        
        if (warnings.length > 0) {
          this.showAlert(warnings.join('\n'));
        }
      }
      
      showAlert(message) {
        // Alert visible pour vous
        const alertDiv = document.createElement('div');
        alertDiv.style.cssText = `
          position: fixed;
          top: 10px;
          right: 10px;
          background: #ff4444;
          color: white;
          padding: 15px;
          border-radius: 5px;
          z-index: 10000;
          max-width: 300px;
          box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        `;
        alertDiv.innerHTML = `
          <strong>üö® LIMITE APPROCHANTE</strong>
          <div style="margin-top: 8px; font-size: 12px;">${message}</div>
          <button onclick="this.parentElement.remove()" style="margin-top: 8px; padding: 5px;">Fermer</button>
        `;
        document.body.appendChild(alertDiv);
        
        // Email automatique √† vous-m√™me
        this.sendAlertEmail(message);
      }
      
      async sendAlertEmail(message) {
        try {
          await emailjs.send('service_wreyh0i', 'template_5enx2ae', {
            to_email: 'elmessaoudianiss@gmail.com',
            subject: 'üö® Manima - Limite de service approchante',
            message: message
          });
        } catch (error) {
          console.log('Email alert non envoy√©:', error);
        }
      }
      
      dailyReport() {
        console.log('üìä RAPPORT QUOTIDIEN - Manima:');
        console.log(`üìà Firebase lectures: ${this.usage.firebaseReads}`);
        console.log(`üìà Firebase √©critures: ${this.usage.firebaseWrites}`);
        console.log(`üó∫Ô∏è Mapbox appels: ${this.usage.mapboxCalls}`);
        console.log(`üìß Emails envoy√©s: ${this.usage.emailSends}`);
        console.log(`üå§Ô∏è Appels m√©t√©o: ${this.usage.weatherCalls}`);
        
        // R√©initialiser les compteurs
        this.usage = {
          firebaseReads: 0,
          firebaseWrites: 0, 
          mapboxCalls: 0,
          emailSends: 0,
          weatherCalls: 0
        };
      }
    }

    // D√©marrer le monitoring - ATTENDRE que tout soit charg√©
    setTimeout(() => {
      window.serviceMonitor = new ServiceMonitor();
      console.log('‚úÖ Monitoring des services activ√©');
    }, 2000);

    const CLOUDINARY_URL = 'https://api.cloudinary.com/v1_1/duea4ynnh/upload';
    const CLOUDINARY_UPLOAD_PRESET = 'avis_image';

    let utilisateurConnecte = null;
    firebase.auth().onAuthStateChanged(async (user) => {
      utilisateurConnecte = user;
      console.log("Utilisateur connect√©:", {
        email: user?.email,
        verified: user?.emailVerified,
        providers: user?.providerData?.map(p => p.providerId)
      });

      if (user) {
        const userRef = db.ref(`utilisateurs/${user.uid}`);
        const snapshot = await userRef.once('value');
        const data = snapshot.val() || {};

        // Si l'email n'est pas encore enregistr√© dans la base, on le sauvegarde
        if (!data.email && user.email) {
          await userRef.update({
            email: user.email,
            displayName: user.displayName || 'Utilisateur',
            nom: user.displayName || 'Utilisateur'
          });
        }

        // Facultatif : v√©rifier si le bouton commandant doit s'afficher
        verifierStatutCommandant();
      }
    });

    const map = L.map('map').setView([50.6292, 3.0573], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    const geocoder = L.Control.geocoder({ defaultMarkGeocode: false })
      .on('markgeocode', function(e) {
        const center = e.geocode.center;
        map.setView(center, 17);
        tracerItineraire([center.lat, center.lng]);
      }).addTo(map);
  
  // REMPLACEZ la fonction normaliserNomPourFirebase par cette version am√©lior√©e
function normaliserNomPourFirebase(nom) {
  if (!nom) return "";
  
  // Garder le nom original autant que possible
  // Seulement √©chapper les caract√®res vraiment interdits par Firebase
  return nom
    .replace(/\./g, '_')
    .replace(/\$/g, '_')
    .replace(/#/g, '_')
    .replace(/\[/g, '_')
    .replace(/\]/g, '_')
    .replace(/\//g, '_');
    
  // NE PAS remplacer les apostrophes, espaces et caract√®res accentu√©s
}




// Variables globales pour le classement
let snackRankingData = [];

// Fonction pour afficher le classement des snacks
async function afficherClassementSnacks() {
  document.getElementById('snack-ranking-modal').style.display = 'block';
  
  // Afficher un indicateur de chargement
  document.getElementById('snack-ranking-list').innerHTML = `
    <div style="text-align: center; padding: 40px;">
      <div class="loading-dots">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <p>Chargement du classement Snack Clash...</p>
    </div>
  `;
  
  try {
    // Charger les donn√©es depuis Firestore (collection 'snacks' de Snack Clash)
    await chargerDonneesSnacksFirestore();
    
    // Afficher le classement
    afficherListeClassement();
    
  } catch (error) {
    console.error("Erreur lors du chargement du classement:", error);
    document.getElementById('snack-ranking-list').innerHTML = `
      <div style="text-align: center; padding: 40px; color: #ff4444;">
        <p>Erreur lors du chargement du classement</p>
        <p style="font-size: 12px; margin-top: 10px;">${error.message}</p>
        <button onclick="afficherClassementSnacks()" style="padding: 10px 20px; background: #ff4444; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 15px;">
          R√©essayer
        </button>
      </div>
    `;
  }
}

// Fonction pour charger les donn√©es depuis Firestore
async function chargerDonneesSnacksFirestore() {
  try {
    console.log("üì° Chargement des snacks depuis Firestore...");
    
    // Utiliser Firestore au lieu de Realtime Database
    const snapshot = await firebase.firestore().collection('snacks').get();
    
    snackRankingData = [];
    
    if (snapshot.empty) {
      console.log("‚ùå Aucun snack trouv√© dans Firestore");
      throw new Error("Aucun snack trouv√© dans la base de donn√©es Snack Clash");
    }
    
    // R√©cup√©rer tous les snacks avec leurs scores ELO
    snapshot.forEach(doc => {
      const snackData = doc.data();
      console.log("üìä Snack trouv√©:", snackData.name, "ELO:", snackData.eloRating);
      
      snackRankingData.push({
        id: doc.id,
        name: snackData.name || 'Snack sans nom',
        score: snackData.eloRating || 1400, // Score ELO de Snack Clash
        adresse: snackData.address || snackData.adresse || 'Adresse inconnue',
        specialite: snackData.type || 'Snack',
        votes: snackData.totalComparisons || 0,
        wins: snackData.wins || 0,
        losses: snackData.losses || 0
      });
    });
    
    // Trier par score ELO d√©croissant (les meilleurs en premier)
    snackRankingData.sort((a, b) => b.score - a.score);
    
    console.log(`‚úÖ ${snackRankingData.length} snacks charg√©s depuis Snack Clash`);
    
  } catch (error) {
    console.error("‚ùå Erreur Firestore:", error);
    throw new Error("Impossible de charger les donn√©es Snack Clash");
  }
}

// Fonction pour afficher la liste de classement
function afficherListeClassement() {
  const rankingList = document.getElementById('snack-ranking-list');
  
  if (snackRankingData.length === 0) {
    rankingList.innerHTML = `
      <div style="text-align: center; padding: 40px; color: #666;">
        <p>Aucun snack trouv√© dans le classement Snack Clash</p>
        <p style="font-size: 12px; margin-top: 10px;">Les snacks appara√Ætront apr√®s les premiers votes sur Snack Clash</p>
      </div>
    `;
    return;
  }
  
  let html = '';
  
  snackRankingData.forEach((snack, index) => {
    const position = index + 1;
    const medal = position === 1 ? 'ü•á' : position === 2 ? 'ü•à' : position === 3 ? 'ü•â' : `${position}.`;
    
    // Calculer le pourcentage de victoires
    const winRate = snack.votes > 0 ? Math.round((snack.wins / snack.votes) * 100) : 0;
    
    html += `
  <div class="snack-ranking-item" onclick="localiserSnack(\`${snack.name}\`)">
        <div class="ranking-position">${medal}</div>
        <div class="snack-info">
          <div class="snack-name">${snack.name}</div>
          <div class="snack-details">
            ${snack.specialite} ‚Ä¢ ${snack.adresse}
            <br>
            <small>${snack.votes} combats ‚Ä¢ ${winRate}% de victoires ‚Ä¢ ELO: ${snack.score}</small>
          </div>
        </div>
        <div class="snack-score">${snack.score}</div>
      </div>
    `;
  });
  
  rankingList.innerHTML = html;
}

// FONCTION LOCALISER SNACK ROBUSTE
function localiserSnack(nomSnack) {
    fermerClassementSnacks();
    
    console.log("üìç Recherche du snack:", nomSnack);
    
    // Essayer les deux types d'apostrophes
    const nomsAlternatifs = [
        nomSnack.trim(), // Version originale
        nomSnack.replace(/'/g, '‚Äô'), // Apostrophe courbe
        nomSnack.replace(/‚Äô/g, "'"), // Apostrophe droite
        "L'Artiste", // Forcer les deux versions
        "L‚ÄôArtiste"
    ];
    
    // Supprimer les doublons
    const nomsUniques = [...new Set(nomsAlternatifs)];
    
    console.log("Noms √† tester:", nomsUniques);
    
    // Essayer chaque version
    for (const nom of nomsUniques) {
        const service = trouverServiceParNom(nom);
        if (service) {
            console.log(`‚úÖ Trouv√© avec: "${nom}"`);
            centrerSurService(nom);
            return;
        }
    }
    
    console.log("‚ùå Aucune version du nom n'a fonctionn√©");
    
    // Fallback: recherche manuelle
    const found = allFeatures.find(f => 
        f.properties.name && 
        (f.properties.name.includes("Artiste") || f.properties.name.includes("artiste"))
    );
    
    if (found) {
        console.log("‚úÖ Trouv√© par recherche partielle:", found.properties.name);
        centrerSurService(found.properties.name);
    }
}

// Fonction pour fermer le classement
function fermerClassementSnacks() {
  document.getElementById('snack-ranking-modal').style.display = 'none';
}

  // Afficher le formulaire d'avis
  function afficherFormulaireAvis(nom) {
    nomServiceActuel = nom;

    if (!utilisateurConnecte) {
      // Si l'utilisateur n'est pas connect√©, ouvrir la fen√™tre d'authentification
      const provider = new firebase.auth.GoogleAuthProvider();
      firebase.auth().signInWithPopup(provider)
        .then((result) => {
          utilisateurConnecte = result.user;
          afficherFormulaireAvis(nom);  // R√©appel de la fonction apr√®s la connexion
        })
        .catch((error) => {
          alert("Connexion requise pour laisser un avis.");
          console.error(error);
        });
      return;
    }

    // Si l'utilisateur est connect√©, afficher le formulaire
    document.getElementById("titre-avis").innerText = "Avis pour " + nom;
    document.getElementById("pseudo-avis").value = utilisateurConnecte.displayName;
    document.getElementById("pseudo-avis").disabled = true;
    document.getElementById("avis-modal").style.display = "block";
  }

  // Ton code existant continue ici...

    

    let itineraireLayer = L.layerGroup().addTo(map);
    let userLocation = null;
    let userMarker = null;
    let suiviItineraire = false;

    const arrowIcon = L.divIcon({ className: 'arrow-icon', iconSize: [50, 50], iconAnchor: [25, 25] });

    // Modifier la fonction de g√©olocalisation pour une meilleure pr√©cision
navigator.geolocation.watchPosition(pos => {
    userLocation = [pos.coords.latitude, pos.coords.longitude];
    const heading = pos.coords.heading || 0;

    if (userMarker) {
        userMarker.setLatLng(userLocation);
        userMarker.setRotationAngle(heading);
    } else {
        userMarker = L.marker(userLocation, {
            icon: arrowIcon,
            rotationAngle: heading,
            rotationOrigin: 'center center'
        }).addTo(map).bindPopup("üìç Vous √™tes ici").openPopup();
        map.setView(userLocation, 17);
    }

    // Pendant le suivi d'itin√©raire, la carte s'oriente vers l'avant
    if (suiviItineraire) {
        orienterCarteVersDirection(heading);
    }

}, err => console.error("Erreur de g√©olocalisation :", err), {
    enableHighAccuracy: true,
    maximumAge: 1000,
    timeout: 5000
});

    function formaterDuree(minutes) {
      const h = Math.floor(minutes / 60);
      const m = Math.round(minutes % 60);
      return h > 0 ? `${h}h${m > 0 ? ` ${m} min` : ''}` : `${m} min`;
    }

    let currentRoute = null; // Stocke la ligne d'itin√©raire actuelle
let routeCoords = []; // Stocke les coordonn√©es compl√®tes de l'itin√©raire
let routeUpdateInterval = null; // Intervalle de mise √† jour

// Remplacer la fonction tracerItineraire existante par cette version am√©lior√©e
function tracerItineraire(dest) {
    if (!userLocation) return alert("Localisation non disponible");
    

    // Cacher les services
    cacherServices();
    cacherInterfaceItineraire();
    
    // Afficher le bouton Stop
    document.getElementById('stop-itineraire-btn').style.display = 'block';


    // üî• FERMER TOUTES LES POPUPS IMM√âDIATEMENT
    map.closePopup();
    
    // Nettoyage des √©l√©ments pr√©c√©dents
    itineraireLayer.clearLayers();
    if (routeUpdateInterval) clearInterval(routeUpdateInterval);

    // Cr√©ation du conteneur d'informations
    const infoContainerId = "itineraire-infos";
    let infoContainer = document.getElementById(infoContainerId);
    if (!infoContainer) {
        infoContainer = document.createElement("div");
        infoContainer.id = infoContainerId;
        infoContainer.style.padding = "10px";
        infoContainer.style.background = "#fff";
        infoContainer.style.position = "absolute";
        
        // Position adaptative selon l'appareil
        if (window.innerWidth <= 768) {
            infoContainer.style.bottom = "500px"; // Plus haut sur mobile
        } else {
            infoContainer.style.bottom = "450px"; // Position originale sur desktop
        }
        
        infoContainer.style.left = "10px";
        infoContainer.style.zIndex = "999";
        infoContainer.style.borderRadius = "8px";
        infoContainer.style.boxShadow = "0 2px 5px rgba(0,0,0,0.2)";
        map.getContainer().appendChild(infoContainer);
    }
    infoContainer.innerHTML = "";

    const mode = 'driving';
    const url = `https://api.mapbox.com/directions/v5/mapbox/${mode}/${userLocation[1]},${userLocation[0]};${dest[1]},${dest[0]}?geometries=geojson&overview=full&access_token=pk.eyJ1Ijoiam95ZnVsYm95IiwiYSI6ImNtZzI0dXF2NzB0NHEyanNjOWd4eDV1ZmgifQ.pdbOlOlVCE8hxodOIE8x0g`;

    fetch(url)
        .then(res => res.json())
        .then(data => {
            if (!data.routes || data.routes.length === 0) return;

            const route = data.routes[0];
            const durationMin = Math.round(route.duration / 60);
            const durationFormatted = formaterDuree(durationMin);
            const distanceKm = (route.distance / 1000).toFixed(2);

            // Stocke les coordonn√©es compl√®tes de l'itin√©raire
            routeCoords = route.geometry.coordinates;

            // Trace l'itin√©raire complet
            currentRoute = L.geoJSON(route.geometry, {
                style: { color: 'blue', weight: 4 }
            }).addTo(itineraireLayer);

            // üî• CENTRER DIRECTEMENT SUR VOTRE POSITION
            map.setView(userLocation, 17);

            // Affiche les infos
            const line = `<div><strong>üöó En voiture</strong> : ${durationFormatted} (${distanceKm} km)</div>`;
            infoContainer.innerHTML += line;

            // Active le suivi automatique
            suiviItineraire = true;

            // D√©marrer le suivi progressif
            startRouteTracking(dest);
        })
        .catch(err => {
            console.error(`Erreur itin√©raire Mapbox :`, err);
        });
}

// Modifiez la fonction startRouteTracking
function startRouteTracking(destination) {
    let lastRecalculation = Date.now();
    const recalculationInterval = 15000;

    routeUpdateInterval = setInterval(() => {
        if (!userLocation || routeCoords.length < 2) return;

        // üî• SUIVI EN TEMPS R√âEL - La carte suit votre position
        map.setView(userLocation, 17);
        
        // üî• ORIENTATION DE LA CARTE selon votre direction
        if (userMarker && userMarker.options.rotationAngle !== undefined) {
            orienterCarteVersDirection(userMarker.options.rotationAngle);
        }

        // RECALCUL AUTOMATIQUE si √©cart √† l'itin√©raire
        const now = Date.now();
        if (now - lastRecalculation > recalculationInterval || estHorsItineraire()) {
            recalculerItineraire(destination);
            lastRecalculation = now;
        }

        // V√©rifie si arriv√© √† destination
        if (L.latLng(userLocation).distanceTo(destination) < 25) {
            arreterItineraire();
            alert("üéâ Vous √™tes arriv√© √† destination !");
        }
    }, 3000);
}
// Nouvelle fonction pour arr√™ter l'itin√©raire
function arreterItineraire() {
    // Arr√™ter le suivi
    if (routeUpdateInterval) {
        clearInterval(routeUpdateInterval);
        routeUpdateInterval = null;
    }
    
    // R√©initialiser les variables
    suiviItineraire = false;
    servicesVisible = true;
    
    // Nettoyer l'itin√©raire
    itineraireLayer.clearLayers();
    
    // Cacher le bouton Stop
    document.getElementById('stop-itineraire-btn').style.display = 'none';
    
    // Supprimer le conteneur d'informations
    const infoContainer = document.getElementById("itineraire-infos");
    if (infoContainer) {
        infoContainer.remove();
    }
    
    // R√©afficher les services ET l'interface
    if (!clusterLayerVisible) {
        map.addLayer(clusterLayer);
        clusterLayerVisible = true;
    }
    
    // R√©afficher tous les services
    afficherServices("");
    
    // FORCER le r√©affichage du conteneur de recommandations
    const recommandationContainer = document.getElementById('recommandation-container');
    if (recommandationContainer) {
        recommandationContainer.style.display = 'block';
    }
    
    // R√©afficher l'interface compl√®te
    afficherInterfaceItineraire();
    
    console.log("Itin√©raire arr√™t√© - services et interface r√©affich√©s");
}

// Initialisation des clusters et services (conserv√© tel quel)
const clusterLayer = L.markerClusterGroup().addTo(map);
let allFeatures = [];

// Charger uniquement votre fichier lille.geojson
    fetch('yi.geojson')
      .then(res => res.json())
      .then(data => {
        allFeatures = data.features;
        afficherServices("");
      }) 
    // Am√©liorer la fonction d'orientation de la carte
function orienterCarteVersDirection(heading) {
    // Calcule un point "devant" vous pour orienter la vue
    const bearing = (heading * Math.PI) / 180;
    const distance = 0.001; // Environ 100m devant
    
    const latOffset = Math.cos(bearing) * distance;
    const lngOffset = Math.sin(bearing) * distance;
    
    const pointDevant = [
        userLocation[0] + latOffset,
        userLocation[1] + lngOffset
    ];
    
    // Centre la carte entre votre position et le point devant
    const centerLat = (userLocation[0] + pointDevant[0]) / 2;
    const centerLng = (userLocation[1] + pointDevant[1]) / 2;
    
    map.setView([centerLat, centerLng], 17, {
        animate: true,
        duration: 0.5
    });
}
    function recalculerItineraire(destination) {
    if (!userLocation) return;

    const mode = 'driving';
    const url = `https://api.mapbox.com/directions/v5/mapbox/${mode}/${userLocation[1]},${userLocation[0]};${destination[1]},${destination[0]}?geometries=geojson&overview=full&access_token=pk.eyJ1Ijoiam95ZnVsYm95IiwiYSI6ImNtZzI0dXF2NzB0NHEyanNjOWd4eDV1ZmgifQ.pdbOlOlVCE8hxodOIE8x0g`;

    fetch(url)
        .then(res => res.json())
        .then(data => {
            if (!data.routes || data.routes.length === 0) return;

            const route = data.routes[0];
            const durationMin = Math.round(route.duration / 60);
            const durationFormatted = formaterDuree(durationMin);
            const distanceKm = (route.distance / 1000).toFixed(2);

            // Stocke les nouvelles coordonn√©es
            routeCoords = route.geometry.coordinates;

            // Met √† jour l'affichage de l'itin√©raire
            itineraireLayer.clearLayers();
            currentRoute = L.geoJSON(route.geometry, {
                style: { color: 'blue', weight: 4 }
            }).addTo(itineraireLayer);

            // Met √† jour les infos de temps
            const infoContainer = document.getElementById("itineraire-infos");
            if (infoContainer) {
                infoContainer.innerHTML = `<div><strong>üöó En voiture</strong> : ${durationFormatted} (${distanceKm} km)</div>`;
            }

            console.log("Itin√©raire recalcul√© ! Nouveau temps : " + durationFormatted);
        })
        .catch(err => {
            console.error(`Erreur recalcul itin√©raire :`, err);
        });
}
    // Ajouter cette fonction pour d√©tecter si on s'√©carte de l'itin√©raire
function estHorsItineraire() {
    if (!userLocation || routeCoords.length < 2) return false;
    
    // Trouver le point le plus proche sur l'itin√©raire
    let distanceMin = Infinity;
    for (let i = 0; i < routeCoords.length - 1; i++) {
        const pointA = [routeCoords[i][1], routeCoords[i][0]];
        const pointB = [routeCoords[i+1][1], routeCoords[i+1][0]];
        
        const distance = distancePointSegment(userLocation, pointA, pointB);
        if (distance < distanceMin) {
            distanceMin = distance;
        }
    }
    
    // Si on est √† plus de 100m de l'itin√©raire, on consid√®re qu'on s'est tromp√©
    return distanceMin > 100;
}
// Fonction utilitaire pour calculer la distance d'un point √† un segment
function distancePointSegment(point, segmentA, segmentB) {
    const A = point[0] - segmentA[0];
    const B = point[1] - segmentA[1];
    const C = segmentB[0] - segmentA[0];
    const D = segmentB[1] - segmentA[1];

    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = -1;
    
    if (lenSq !== 0) {
        param = dot / lenSq;
    }

    let xx, yy;

    if (param < 0) {
        xx = segmentA[0];
        yy = segmentA[1];
    } else if (param > 1) {
        xx = segmentB[0];
        yy = segmentB[1];
    } else {
        xx = segmentA[0] + param * C;
        yy = segmentA[1] + param * D;
    }

    const dx = point[0] - xx;
    const dy = point[1] - yy;
    
    return Math.sqrt(dx * dx + dy * dy) * 111000; // Conversion en m√®tres
}
    function normalize(str) {
      return (str || "").toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").trim();
    }

    function icon(name) {
      return L.icon({
        iconUrl: `icons/${name}`,
        iconSize: [32, 32],
        iconAnchor: [16, 32],
        popupAnchor: [0, -32]
      });
    }

    function getIconByCategory(properties) {
      const name = (properties.name || "").toLowerCase();
      const amenity = (properties.amenity || "").toLowerCase();
      const leisure = (properties.leisure || "").toLowerCase();
      const shop = (properties.shop || "").toLowerCase();
      const religion = (properties.religion || "").toLowerCase();

      // Mosqu√©e
      if (amenity === "place_of_worship" && religion === "muslim") return icon("mosquee.png");

      // Autres cat√©gories
      if (name.includes("pharm") || name.includes("sant") || amenity === "pharmacy") return icon("sante.png");
      if (name.includes("√©cole") || amenity === "school") return icon("ecole.png");
      if (["hospital", "clinic"].includes(amenity) || name.includes("h√¥pital") || name.includes("clinique")) return icon("sante.png");
      if (["restaurant", "fast_food", "cafe"].includes(amenity) || shop === "restaurant" || name.includes("resto")) return icon("restaurant.png");
      if (["car", "car_repair"].includes(shop) || amenity === "car_repair" || name.includes("garage")) return icon("garage.png");
      if (leisure === "sports_centre" || amenity === "gym" || name.includes("sport")) return icon("sport.png");
      if (["atm", "bank", "bureau_de_change"].includes(amenity)) return icon("financier.png");
      if (["cinema", "arts_centre", "theatre"].includes(amenity) || leisure === "cinema" ||  name.includes("th√©√¢tre")) return icon("culture.png");
      if (["fire_station", "post_office", "courthouse", "police", "community_centre"].includes(amenity)) return icon("administration.png");
      if (["car_rental", "car_sharing", "car_wash", "fuel", "charging_station", "bicycle_rental"].includes(amenity)) return icon("transport.png");
      if (["childcare", "kindergarten", "animal_boarding", "animal_shelter"].includes(amenity) || name.includes("chien") || name.includes("chat")) return icon("animal.png");
      if (["coworking_space", "give_box"].includes(amenity)) return icon("culture.png");
      if (["bench", "fountain", "clock"].includes(amenity)) return icon("default.png");
      if (shop !== "") return icon("shop.png");
      if (amenity === "boulangerie" || name.includes("boulang")) return icon("boulangerie.png");
      if (amenity === "coiffeur" || name.includes("coiff")) return icon("coiffeur.png");
      if (amenity === "garage" || name.includes("garage")) return icon("garage.png");
      if (amenity === "restaurant" || name.includes("resto")) return icon("restaurant.png");
      if (amenity === "pharmacie" || name.includes("pharm")) return icon("pharmacie.png");
      if (amenity === "supermarche" || name.includes("supermarche")) return icon("supermarche.png");

      return icon("default.png");
    }

    // Variables globales pour g√©rer l'√©tat des marqueurs
let servicesVisible = true;
let clusterLayerVisible = true;

// Fonction pour cacher les services
function cacherServices() {
    if (clusterLayerVisible) {
        map.removeLayer(clusterLayer);
        clusterLayerVisible = false;
        servicesVisible = false;
    }
}

function demarrerItineraire() {
  // Votre logique pour d√©marrer l'itin√©raire
  document.getElementById('stop-itineraire-btn').style.display = 'block';
}

function stopItineraire() {
  // Votre logique pour arr√™ter l'itin√©raire
  document.getElementById('stop-itineraire-btn').style.display = 'none';
}

// Fonction pour cacher tous les √©l√©ments d'interface pendant l'itin√©raire
function cacherInterfaceItineraire() {
    // Cacher les containers
    document.getElementById('recommandation-container').style.display = 'none';
    document.getElementById('market-container').style.display = 'none';
    document.getElementById('jumua-container').style.display = 'none';
    
    // Cacher les boutons
    document.getElementById('chauffeurs-btn').style.display = 'none';
    document.getElementById('ajouter-commerce-btn').style.display = 'none';
    
    console.log("Interface cach√©e pour l'itin√©raire");
}

// Fonction pour r√©afficher tous les √©l√©ments d'interface
function afficherInterfaceItineraire() {
    // R√©afficher les containers (ils se g√®rent eux-m√™mes selon l'heure/jour)
    showRecommendations();
    showJumuaMosques();
    
    // R√©afficher les boutons
    document.getElementById('chauffeurs-btn').style.display = 'block';
    document.getElementById('ajouter-commerce-btn').style.display = 'block';
    
    // FORCER l'affichage du conteneur de recommandations
    const recommandationContainer = document.getElementById('recommandation-container');
    if (recommandationContainer) {
        recommandationContainer.style.display = 'block';
    }
    
    console.log("Interface r√©affich√©e apr√®s itin√©raire");
}
// Correction de la fonction afficherServices
// FONCTION DE RECHERCHE ULTRA-INTELLIGENTE
// CORRECTION DE LA RECHERCHE INTELLIGENTE - Version am√©lior√©e
function afficherServices(filtre = "") {
    console.log("üß† Recherche intelligente:", filtre);
    
    // Si on est en mode itin√©raire, on ne fait rien
    if (suiviItineraire && !servicesVisible) {
        console.log("Mode itin√©raire - services cach√©s");
        return;
    }

    // Nettoyage des layers
    itineraireLayer.clearLayers();

    // Si le cluster layer n'est pas sur la carte, on l'ajoute
    if (!clusterLayerVisible) {
        map.addLayer(clusterLayer);
        clusterLayerVisible = true;
    }

    clusterLayer.clearLayers();

    if (!allFeatures || allFeatures.length === 0) {
        console.log("‚ùå Aucune donn√©e charg√©e");
        return;
    }

    let count = 0;
    let servicesTrouves = [];
    const filtreMin = normalize(filtre);

    // Si recherche vide, on affiche tout
    if (!filtreMin) {
        console.log("‚úÖ Affichage de tous les services");
        allFeatures.forEach(f => {
            if (!f.geometry || f.geometry.type !== "Point") return;
            const props = f.properties;
            const name = props.name;
            if (!name || name.trim() === "") return;

            const [lng, lat] = f.geometry.coordinates;
            const marker = createMarker(props, lat, lng);
            clusterLayer.addLayer(marker);
            count++;
        });

        if (userLocation) map.setView(userLocation, 15);
        console.log(`üìä Total services: ${count}`);
        return;
    }

    // üî• RECHERCHE INTELLIGENTE AVEC SYNONYMES
    let typesRecherches = new Set();

    for (const [keyword, types] of Object.entries(keywordToTypes)) {
        const normalizedKeyword = normalize(keyword);

        // Match si la recherche contient un morceau du mot-cl√© ou inverse
        if (filtreMin.includes(normalizedKeyword) || normalizedKeyword.includes(filtreMin)) {
            types.forEach(type => typesRecherches.add(type));
            continue;
        }

        // Match partiel : chaque mot du filtre est compar√©
        const motsFiltre = filtreMin.split(/\s+/);
        for (const mot of motsFiltre) {
            if (mot.length > 2 && (normalizedKeyword.includes(mot) || mot.includes(normalizedKeyword))) {
                types.forEach(type => typesRecherches.add(type));
            }
        }
    }

    // 2. Recherche textuelle directe
    allFeatures.forEach(f => {
        if (!f.geometry || f.geometry.type !== "Point") return;
        const props = f.properties;
        const name = props.name;
        if (!name || name.trim() === "") return;

        const searchFields = [
            props.name || '',
            props.amenity || '',
            props.shop || '',
            props.leisure || '',
            props.category || '',
            props.type || '',
            props.description || ''
        ].map(normalize).join(' ');

        let match = false;

        // Match par types si recherche intelligente a trouv√©
        if (typesRecherches.size > 0) {
            const type = props.type ? normalize(props.type) : '';
            const amenity = props.amenity ? normalize(props.amenity) : '';
            const leisure = props.leisure ? normalize(props.leisure) : '';
            const shop = props.shop ? normalize(props.shop) : '';

            match = Array.from(typesRecherches).some(typeRecherche => {
                return type.includes(typeRecherche) ||
                       amenity.includes(typeRecherche) ||
                       leisure.includes(typeRecherche) ||
                       shop.includes(typeRecherche) ||
                       normalize(name).includes(typeRecherche);
            });
        }

        // Si pas de match intelligent, recherche textuelle simple
        if (!match) {
            const motsRecherche = filtreMin.split(/\s+/);
            match = motsRecherche.every(mot => searchFields.includes(mot));
        }

        if (match) {
            const [lng, lat] = f.geometry.coordinates;
            const marker = createMarker(props, lat, lng);
            clusterLayer.addLayer(marker);
            servicesTrouves.push({ lat, lng, name: props.name });
            count++;
        }
    });

    console.log(`üéØ Services trouv√©s: ${servicesTrouves.length}`);
    console.log("Types recherch√©s:", Array.from(typesRecherches));

    // CENTRAGE INTELLIGENT
    if (servicesTrouves.length > 0) {
        if (servicesTrouves.length === 1) {
            const service = servicesTrouves[0];
            map.setView([service.lat, service.lng], 16);
        } else {
            const group = new L.featureGroup();
            servicesTrouves.forEach(service => {
                group.addLayer(L.marker([service.lat, service.lng]));
            });
            map.fitBounds(group.getBounds(), { padding: [20, 20], maxZoom: 15 });
        }
    } else if (userLocation) {
        map.setView(userLocation, 15);
    }

    console.log(`üìä Total affich√©: ${count}`);
}

// FONCTION NORMALISATION AM√âLIOR√âE
function normalize(str) {
    return (str || "")
        .toLowerCase()
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .replace(/[^a-z0-9\s]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
}

// √âcouteur de recherche MODIFI√â - arr√™te l'itin√©raire si recherche pendant navigation
document.addEventListener('DOMContentLoaded', function() {
    const searchBar = document.getElementById('search-bar');
    searchBar.addEventListener('input', function(e) {
        const filtre = e.target.value.trim();
        console.log("Recherche:", filtre);
        
        // Si on est en mode itin√©raire, on arr√™te d'abord l'itin√©raire
        if (suiviItineraire) {
            arreterItineraire();
        }
        
        afficherServices(filtre);
    });
});


function centrerSurPlusProche(services) {
  if (!userLocation || services.length === 0) return;
  
  let serviceLePlusProche = services[0];
  let distanceMinimale = calculerDistance(userLocation[0], userLocation[1], services[0].lat, services[0].lng);
  
  // Trouver le service le plus proche
  for (let i = 1; i < services.length; i++) {
    const service = services[i];
    const distance = calculerDistance(userLocation[0], userLocation[1], service.lat, service.lng);
    
    if (distance < distanceMinimale) {
      distanceMinimale = distance;
      serviceLePlusProche = service;
    }
  }
  
  // Centrer sur le service le plus proche
  map.setView([serviceLePlusProche.lat, serviceLePlusProche.lng], 15);
}

function calculerDistance(lat1, lon1, lat2, lon2) {
  const R = 6371; // Rayon de la Terre en km
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
    Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

function normaliserNomPourFirebase(nom) {
  if (!nom) return "";
  return nom.replace(/[.#$\[\]']/g, "_"); 
  // on remplace tous les caract√®res interdits par "_"
}

function matchesFilter(props, filter) {
  if (!filter) return true; // filtre vide = tout afficher
  const filterWords = filter.split(/\s+/).map(normalize);

  // Champs pertinents pour la recherche
  const fields = [
    props.name,
    props.type,
    props.amenity,
    props.shop,
    props.leisure,
    props.category,
    props.address
  ].filter(Boolean).map(normalize);

  // Chaque mot du filtre doit matcher le d√©but d‚Äôun mot d‚Äôun champ
  return filterWords.every(fw => fields.some(f => f.startsWith(fw)));
}

// REMPLACE ta fonction createMarker par ceci :
function createMarker(props, lat, lng) {
    const nomEchappe = props.name.replace(/'/g, "\\'");
    
    let popupContent = `<b>${props.name}</b><br>${props.address || ''}<br>`;

    // Boutons principaux
    popupContent += `
        ${props.phone ? `<button class="popup-btn call-btn" onclick="window.location.href='tel:${props.phone}'">üìû Appeler</button>` : ''}
        ${props.website ? `<button class="popup-btn" onclick="window.open('${props.website}', '_blank')">üåê Site web</button>` : ''}`;
    
    if (props.opening_hours) {
        const formattedHours = props.opening_hours.replace(/\n/g, '<br>');
        popupContent += `<button class="popup-btn" onclick="afficherDetailsPopup('${encodeURIComponent(props.name).replace(/'/g, "\\'")}', 'Horaires', '${formattedHours.replace(/'/g, "\\'")}')">üïí Horaires</button>`;
    }
    
    if (props.price || props.tarifs) {
        const tarifs = props.price || props.tarifs;
        const formattedTarifs = tarifs.replace(/\n/g, '<br>');
        popupContent += `<button class="popup-btn" onclick="afficherDetailsPopup('${props.name}', 'Tarifs', \`${formattedTarifs}\`)">üí∞ Tarifs</button>`;
    }
    
    popupContent += `
        <button class="popup-btn" onclick="map.closePopup(); tracerItineraire([${lat}, ${lng}])">üöó Itin√©raire</button>
        <button class="popup-btn" onclick="afficherFormulaireAvis('${props.name.replace(/'/g, "\\'")}')">üí¨ Laisser un avis</button>
        <button class="popup-btn" onclick="voirAvis('${props.name.replace(/'/g, "\\'")}')">üëÄ Voir les avis</button>
        <button class="popup-btn" onclick="afficherQRModal('${props.name.replace(/'/g, "\\'")}', ${lat}, ${lng})">üì± Partager</button>
        <button class="popup-btn" onclick="afficherStreetView(${lat}, ${lng})">üåç Street View</button>
    `;

    const marker = L.marker([lat, lng], {
        icon: getIconByCategory(props)
    }).bindPopup(popupContent);

    // VERSION CORRIG√âE - Gestion am√©lior√©e des clics
    marker.on('click', function(e) {
        // Fermer tous les popups IMM√âDIATEMENT
        map.closePopup();
        
        // Attendre un court instant pour √©viter les conflits
        setTimeout(() => {
            // V√©rifier si le marqueur est dans un cluster
            const parentCluster = clusterLayer.getVisibleParent(marker);
            
            if (parentCluster && parentCluster !== marker) {
                // D√©velopper le cluster d'abord
                parentCluster.once('spiderfied', function() {
                    setTimeout(() => {
                        marker.openPopup();
                    }, 100);
                });
                parentCluster.spiderfy();
            } else {
                // Ouvrir directement
                marker.openPopup();
            }
        }, 10);
    });

    return marker;
}




// Nouvelle fonction pour afficher les d√©tails dans une popup
function afficherDetailsPopup(nom, type, contenu) {
  nom = decodeURIComponent(nom);
  // Cr√©er une fen√™tre popup plus grande
  const popup = L.popup({ className: 'custom-popup', maxWidth: 400 })
    .setContent(`
      <div class="details-header">
        <h3>${nom}</h3>
        <h4>${type}</h4>
      </div>
      <div class="details-content">
        ${contenu}
      </div>
    `)
    .setLatLng(map.getCenter())
    .openOn(map);
}


function afficherHorairesPopup(nomService, horaires) {
  // Formater les horaires pour un affichage plus lisible
  const horairesFormatted = horaires.replace(/;/g, '<br>');
  
  // Cr√©er une popup Leaflet
  L.popup()
    .setLatLng(map.getCenter())
    .setContent(`
      <div style="max-width: 300px; padding: 10px;">
        <h3 style="margin-top: 0;">Horaires - ${nomService}</h3>
        <div>${horairesFormatted}</div>
      </div>
    `)
    .openOn(map);
}
async function verifierPremierAvis(uid) {
    // V√©rifier d'abord si l'email a d√©j√† √©t√© envoy√©
    const userSnapshot = await db.ref(`utilisateurs/${uid}`).once('value');
    if (userSnapshot.exists() && userSnapshot.val().emailBienvenueEnvoye) {
      return false;
    }

    // Ensuite v√©rifier s'il a d'autres avis
    const avisSnapshot = await db.ref('avis').once('value');
    const tousLesAvis = avisSnapshot.val();
  
    if (!tousLesAvis) return true;
  
    for (const service in tousLesAvis) {
      for (const avisId in tousLesAvis[service]) {
        if (tousLesAvis[service][avisId].uid === uid) {
          return false;
        }
      }
    }
    return true;
  }


async function envoyerEmailPremierAvis(email, nom) {
  try {
    if (!email || !email.includes('@')) {
      console.error("‚ùå Email invalide:", email);
      throw new Error("Email invalide");
    }

    console.log("üìß Tentative d'envoi d'email de bienvenue √†:", email);
    
    const templateParams = {
      to_email: email,
      user_name: nom,
      message: "Bienvenue sur Manimap ! Merci pour votre premier avis. Votre contribution aide toute la communaut√© √† d√©couvrir les meilleurs services autour de Lille.",
      reply_to: "no-reply@manimap.com",
      subject: "Bienvenue sur Manimap ! üéâ"
    };

    console.log("üì® Param√®tres email:", templateParams);
    
    const result = await emailjs.send("service_wreyh0i", "template_5enx2ae", templateParams);
    
    console.log("‚úÖ Email de bienvenue envoy√© avec succ√®s:", result);
    return result;
    
  } catch (error) {
    console.error("‚ùå Erreur d√©taill√©e lors de l'envoi de l'email:", {
      status: error.status,
      text: error.text,
      email: email,
      error: error
    });
    throw error;
  }
}




// Fonction d'upload vers Cloudinary
async function uploadToCloudinary(file, type) {
  const formData = new FormData();
  formData.append("file", file);
  formData.append("upload_preset", CLOUDINARY_UPLOAD_PRESET);
  const response = await fetch(CLOUDINARY_URL, {
    method: "POST",
    body: formData
  });
  const data = await response.json();
  return data.secure_url;
}

 

const verifierEtEnvoyerEmailSiPremierAvis = async () => {
  console.log("üîç V√©rification premier avis...");
  
  if (!utilisateurConnecte) {
    console.log("‚ùå Utilisateur non connect√©");
    return;
  }

  const uid = utilisateurConnecte.uid;
  console.log("üë§ UID utilisateur:", uid);

  // V√©rifier d'abord si l'email a d√©j√† √©t√© envoy√© pour cet utilisateur
  const userRef = db.ref(`utilisateurs/${uid}`);
  const userSnapshot = await userRef.once('value');
  const userData = userSnapshot.val() || {};
  
  console.log("üìä Donn√©es utilisateur:", userData);
  
  if (userData.emailBienvenueEnvoye) {
    console.log("‚úÖ Email de bienvenue d√©j√† envoy√© pour cet utilisateur");
    return;
  }

  // üî• CORRECTION : V√©rifier si c'est le premier avis AVANT d'envoyer l'email
  const avisGlobalRef = db.ref('avis');
  const snapshot = await avisGlobalRef.once('value');
  const tousLesAvis = snapshot.val();
  
  console.log("üìù Total avis dans la base:", tousLesAvis ? Object.keys(tousLesAvis).length : 0);

  let premierAvis = true;
  let avisTrouves = 0;

  if (tousLesAvis) {
    for (const service in tousLesAvis) {
      const avisService = tousLesAvis[service];
      for (const avisId in avisService) {
        const unAvis = avisService[avisId];
        if (unAvis.uid === uid) {
          avisTrouves++;
          premierAvis = false;
          console.log(`üìå Avis trouv√©: ${service} - ${avisId}`);
          break;
        }
      }
      if (!premierAvis) break;
    }
  }

  console.log(`üéØ R√©sultat v√©rification: ${premierAvis ? 'PREMIER AVIS' : `AVIS EXISTANTS (${avisTrouves} trouv√©s)`}`);

  // üî• CORRECTION : Envoyer l'email seulement si c'est vraiment le premier avis
  if (premierAvis) {
    console.log("üéâ Premier avis d√©tect√©! Envoi de l'email de bienvenue");
    
    if (utilisateurConnecte?.email) {
      console.log("üìß Email trouv√©:", utilisateurConnecte.email);
      
      try {
        // Envoyer l'email
        await envoyerEmailPremierAvis(
          utilisateurConnecte.email, 
          utilisateurConnecte.displayName || "Utilisateur"
        );
        
        // Marquer que l'email a √©t√© envoy√©
        await userRef.update({
          emailBienvenueEnvoye: true,
          datePremierAvis: new Date().toISOString(),
          dernierAvis: new Date().toISOString()
        });
        
        console.log("‚úÖ Email de bienvenue envoy√© et marqu√© dans la base");
        
      } catch (error) {
        console.error("‚ùå Erreur lors de l'envoi de l'email:", error);
      }
    } else {
      console.warn("‚ö†Ô∏è Aucun email disponible pour l'utilisateur");
      console.log("üë§ D√©tails utilisateur:", {
        email: utilisateurConnecte.email,
        displayName: utilisateurConnecte.displayName,
        providerData: utilisateurConnecte.providerData
      });
    }
  } else {
    console.log("‚ÑπÔ∏è Ce n'est pas le premier avis, pas d'email envoy√©");
    
    // üî• NOUVEAU : Marquer quand m√™me l'utilisateur comme ayant d√©j√† des avis
    // pour √©viter de refaire la v√©rification √† chaque fois
    await userRef.update({
      emailBienvenueEnvoye: true, // On marque comme d√©j√† envoy√© m√™me si ce n'est pas le cas
      datePremierAvis: new Date().toISOString(),
      dernierAvis: new Date().toISOString()
    });
  }
};


    function fermerModal() {
      document.getElementById("avis-modal").style.display = "none";
    }

    function voirAvis(nom) {
      afficherAvis(nom);
    }
    

    // Fonction pour afficher le formulaire d'avis - VERSION CORRIG√âE
let nomServiceActuel = null;

function afficherFormulaireAvis(nom) {
    nomServiceActuel = nom;

    if (!utilisateurConnecte) {
        const provider = new firebase.auth.GoogleAuthProvider();
        firebase.auth().signInWithPopup(provider)
            .then((result) => {
                utilisateurConnecte = result.user;
                afficherFormulaireAvis(nom);
            })
            .catch((error) => {
                alert("Connexion requise pour laisser un avis.");
                console.error(error);
            });
        return;
    }

    document.getElementById("titre-avis").innerText = "Avis pour " + nom;
    document.getElementById("pseudo-avis").value = utilisateurConnecte.displayName;
    document.getElementById("pseudo-avis").disabled = true;
    document.getElementById("avis-modal").style.display = "block";
}

// Gestion de la soumission du formulaire d'avis - VERSION CORRIG√âE
document.getElementById("avis-form").addEventListener("submit", async function(e) {
    e.preventDefault();

    if (!utilisateurConnecte) {
        alert("Vous devez √™tre connect√© pour soumettre un avis.");
        return;
    }

    const textAvis = document.getElementById("text-avis").value.trim();
    if (!textAvis) {
        alert("Veuillez √©crire un avis.");
        return;
    }

    const photoFile = document.getElementById("photo-avis").files[0];
    const videoFile = document.getElementById("video-avis").files[0];

    try {
        let photoUrl = null;
        let videoUrl = null;

        // Upload de la photo si elle existe
        if (photoFile) {
            photoUrl = await uploadToCloudinary(photoFile, "image");
        }

        // Upload de la vid√©o si elle existe
        if (videoFile) {
            videoUrl = await uploadToCloudinary(videoFile, "video");
        }

        // Pr√©parer l'avis
        const nouvelAvis = {
            text: textAvis,
            pseudo: utilisateurConnecte.displayName || "Anonyme",
            uid: utilisateurConnecte.uid,
            date: new Date().toLocaleDateString('fr-FR'),
            photoUrl: photoUrl,
            videoUrl: videoUrl,
            pointsVerts: 0,
            pointsRouges: 0,
            voteurs: {}
        };

        // 1. V√âRIFIER si c'est le premier avis AVANT la sauvegarde
        const estPremierAvis = await verifierSiPremierAvis(utilisateurConnecte.uid);
        
        // Utiliser le nom original autant que possible
        const nomPourSauvegarde = nomServiceActuel; // Utiliser le nom original
        const avisRef = db.ref('avis/' + nomPourSauvegarde).push();
        await avisRef.set(nouvelAvis);

        // 3. Envoyer l'email seulement si c'est le premier avis
        if (estPremierAvis) {
            console.log("üéâ Premier avis d√©tect√©! Envoi de l'email de bienvenue");
            await envoyerEmailPremierAvis(
                utilisateurConnecte.email, 
                utilisateurConnecte.displayName || "Utilisateur"
            );
            
            // Marquer que l'email a √©t√© envoy√©
            const userRef = db.ref(`utilisateurs/${utilisateurConnecte.uid}`);
            await userRef.update({
                emailBienvenueEnvoye: true,
                datePremierAvis: new Date().toISOString()
            });
        }

        // R√©initialiser le formulaire
        document.getElementById("avis-form").reset();
        fermerModal();
        
        alert("Votre avis a √©t√© publi√© avec succ√®s !");

    } catch (error) {
        console.error("Erreur lors de la soumission de l'avis:", error);
        alert("Une erreur est survenue lors de la publication de votre avis.");
    }
});

// Nouvelle fonction pour v√©rifier si premier avis
async function verifierSiPremierAvis(uid) {
    const avisGlobalRef = db.ref('avis');
    const snapshot = await avisGlobalRef.once('value');
    const tousLesAvis = snapshot.val();
    
    if (!tousLesAvis) return true;
    
    for (const service in tousLesAvis) {
        const avisService = tousLesAvis[service];
        for (const avisId in avisService) {
            if (avisService[avisId].uid === uid) {
                return false;
            }
        }
    }
    return true;
}

// Fonction pour supprimer un avis - VERSION CORRIG√âE
async function supprimerAvis(nomService, avisId) {
    if (!utilisateurConnecte) return;
    
    if (!confirm("√ätes-vous s√ªr de vouloir supprimer cet avis ?")) {
        return;
    }

    try {
        console.log("üóëÔ∏è Tentative de suppression:", { nomService, avisId });

        // Chercher l'avis avec diff√©rentes variantes du nom
        const variantes = [
            nomService, // Nom original
            nomService.replace(/'/g, "_"), // Apostrophes remplac√©es
            normaliserNomPourFirebase(nomService) // Version normalis√©e
        ];

        let avisSupprime = false;

        for (const variante of variantes) {
            try {
                const avisRef = db.ref(`avis/${variante}/${avisId}`);
                const snapshot = await avisRef.once('value');
                
                if (snapshot.exists()) {
                    await avisRef.remove();
                    console.log("‚úÖ Avis supprim√© avec la variante:", variante);
                    avisSupprime = true;
                    break;
                }
            } catch (error) {
                console.log(`‚ùå √âchec avec la variante ${variante}:`, error);
            }
        }

        if (avisSupprime) {
            // Recharger les avis avec le nom original
            afficherAvis(nomService);
            alert("Avis supprim√© avec succ√®s.");
        } else {
            alert("Impossible de trouver l'avis √† supprimer.");
        }
    } catch (error) {
        console.error("Erreur lors de la suppression:", error);
        alert("Erreur lors de la suppression de l'avis.");
    }
}
// Fonction helper pour √©viter les probl√®mes de syntaxe
function supprimerAvisSafe(nomService, avisId) {
    // Nettoyer les √©chappements excessifs
    const nomServicePropre = nomService.replace(/\\'/g, "'");
    const avisIdPropre = avisId.replace(/\\'/g, "'");
    
    supprimerAvis(nomServicePropre, avisIdPropre);
}
    function afficherAvis(nom) {
    document.getElementById("liste-avis-modal").style.display = "block";
    document.getElementById("titre-liste-avis").innerText = "Avis sur " + nom;

    const contenuAvis = document.getElementById("contenu-avis");
    contenuAvis.innerHTML = "<div class='loading-dots'><div class='dot'></div><div class='dot'></div><div class='dot'></div></div>";

    // FORCER le redimensionnement pour activer le scroll
    setTimeout(() => {
        const modalContent = document.querySelector('#liste-avis-modal .modal-content');
        if (modalContent) {
            modalContent.style.display = 'flex';
            modalContent.style.flexDirection = 'column';
        }
    }, 100);

    // NOUVELLE APPROCHE : Chercher avec plusieurs variantes du nom
    const variantes = [
        nom, // Nom original
        normaliserNomPourFirebase(nom), // Version normalis√©e
        nom.replace(/'/g, "_"), // Juste les apostrophes remplac√©es
        nom.replace(/[¬¥'`‚Äô]/g, "_") // Tous types d'apostrophes
    ];

    // Supprimer les doublons
    const variantesUniques = [...new Set(variantes.filter(v => v))];

    console.log("üîç Recherche des avis avec variantes:", variantesUniques);

    chercherAvisAvecVariantes(variantesUniques, nom, 0);

    function chercherAvisAvecVariantes(variantes, nomAffichage, index) {
        if (index >= variantes.length) {
            console.log("‚ùå Aucun avis trouv√© avec aucune variante");
            contenuAvis.innerHTML = "<div style='text-align:center; padding:20px; color: #666;'><i>Aucun avis pour ce lieu pour le moment</i></div>";
            return;
        }

        const varianteActuelle = variantes[index];
        console.log(`üîç Tentative avec variante ${index + 1}/${variantes.length}: "${varianteActuelle}"`);

        db.ref('avis/' + varianteActuelle).once('value')
            .then(snapshot => {
                if (snapshot.exists()) {
                    console.log(`‚úÖ Avis trouv√©s avec la variante: "${varianteActuelle}"`);
                    traiterAvis(snapshot.val(), nomAffichage, varianteActuelle);
                } else {
                    console.log(`‚ùå Aucun avis avec la variante: "${varianteActuelle}"`);
                    // Essayer la variante suivante
                    chercherAvisAvecVariantes(variantes, nomAffichage, index + 1);
                }
            })
            .catch(error => {
                console.error(`Erreur avec la variante ${varianteActuelle}:`, error);
                // Essayer la variante suivante en cas d'erreur
                chercherAvisAvecVariantes(variantes, nomAffichage, index + 1);
            });
    }

    function traiterAvis(avisList, nomAffichage, varianteUtilisee) {
        console.log(`‚úÖ Affichage des avis trouv√©s avec la variante: "${varianteUtilisee}"`);
        
        const avisArray = Object.entries(avisList).map(([avisId, avis]) => ({ avisId, ...avis }));

        // Le reste du code de traitement des avis reste identique...
        const promises = avisArray.map(avis => {
            return db.ref(`utilisateurs/${avis.uid}`).once('value')
                .then(userSnapshot => {
                    const userData = userSnapshot.val() || {};
                    return {
                        ...avis,
                        hasBadgeMoussaillon: userData.badgeMoussaillon || false,
                        hasBadgeCommandant: userData.badgeCommandant || false
                    };
                });
        });

        Promise.all(promises).then(avisAvecBadges => {
            // Trier par priorit√©: Commandant > Moussaillon > autres
            avisAvecBadges.sort((a, b) => {
                if (b.hasBadgeCommandant && !a.hasBadgeCommandant) return 1;
                if (a.hasBadgeCommandant && !b.hasBadgeCommandant) return -1;
                if (b.hasBadgeMoussaillon && !a.hasBadgeMoussaillon) return 1;
                if (a.hasBadgeMoussaillon && !b.hasBadgeMoussaillon) return -1;
                return 0;
            });

            contenuAvis.innerHTML = '';

            if (avisAvecBadges.length === 0) {
                contenuAvis.innerHTML = "<div style='text-align:center; padding:20px; color: #666;'><i>Aucun avis pour ce lieu</i></div>";
                return;
            }

            avisAvecBadges.forEach(({ avisId, hasBadgeMoussaillon, hasBadgeCommandant, ...avis }) => {
                const avisElement = document.createElement("div");
                avisElement.className = "avis-item";

                const currentUserId = utilisateurConnecte?.uid;
                const isOwnAvis = currentUserId && avis.uid === currentUserId;
                const userVoteType = currentUserId && avis.voteurs?.[currentUserId];

                // UTILISER LA VARIANTE CORRECTE pour les actions
                const nomPourActions = varianteUtilisee;
                const avisIdEchappe = avisId.replace(/'/g, "\\'");

                const voteButtons = `
                    <div style="margin-top:10px; display:flex; gap:15px; font-size:18px;">
                        <span onclick="${!isOwnAvis ? `voterAvis('${nomPourActions}', '${avisIdEchappe}', 'vert')` : 'void(0)'}" 
                              style="cursor:${isOwnAvis ? 'default' : 'pointer'};
                                     ${userVoteType === 'vert' ? 'font-weight:bold; color: green;' : ''}">
                            üü¢ ${avis.pointsVerts || 0}
                        </span>
                        <span onclick="${!isOwnAvis ? `voterAvis('${nomPourActions}', '${avisIdEchappe}', 'rouge')` : 'void(0)'}" 
                              style="cursor:${isOwnAvis ? 'default' : 'pointer'};
                                     ${userVoteType === 'rouge' ? 'font-weight:bold; color: red;' : ''}">
                            üî¥ ${avis.pointsRouges || 0}
                        </span>
                    </div>`;

                let deleteButton = '';
                if (isOwnAvis) {
                    deleteButton = `<button onclick="supprimerAvis('${nomPourActions.replace(/'/g, "\\'")}', '${avisId}')" style="padding:5px 10px; font-size:12px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer;">üóëÔ∏è Supprimer</button>`;
                }

                let badgeHtml = '';
                if (hasBadgeCommandant) {
                    badgeHtml = '<img src="commandant.png" class="badge-moussaillon" title="Commandant" style="width: 30px; height: 30px;">';
                } else if (hasBadgeMoussaillon) {
                    badgeHtml = '<img src="moussaillon2.png" class="badge-moussaillon" title="Moussaillon" style="width: 30px; height: 30px;">';
                }

                avisElement.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <img src="https://ui-avatars.com/api/?name=${encodeURIComponent(avis.pseudo || "A")}&background=4CAF50&color=fff&rounded=true" 
                                 alt="avatar" style="width: 40px; height: 40px; border-radius: 50%;" />
                            <div>
                                <strong style="font-size: 16px;">${avis.pseudo || "anonyme"}</strong>
                                ${badgeHtml}
                                <br>
                                <small style="color: #666;">${avis.date || "Date inconnue"}</small>
                            </div>
                        </div>
                        ${deleteButton}
                    </div>
                    <div style="margin: 10px 0; font-size: 14px; line-height: 1.5;">${avis.text || "(aucun commentaire)"}</div>
                    ${avis.photoUrl ? `<br><img src="${avis.photoUrl}" style="max-width:100%; max-height:200px; margin-top:10px; border-radius:8px;" />` : ""}
                    ${avis.videoUrl ? `<br><video controls style="max-width:100%; max-height:300px; margin-top:10px; border-radius:8px;"><source src="${avis.videoUrl}" type="video/mp4"></video>` : ""}
                    ${voteButtons}
                `;

                contenuAvis.appendChild(avisElement);
            });

            // FORCER le scroll apr√®s chargement
            setTimeout(() => {
                contenuAvis.scrollTop = 0;
            }, 50);
        });
    }
}
    function envoyerEmailBadge(email, nom, badgeType) {
        console.log("envoyerEmailBadge appel√© avec :", email, nom, badgeType);
        if (!email || !email.includes('@')) {
            console.error("Email invalide:", email);
            return;
        }

        const templateParams = {
            to_email: email,
            user_name: nom,
            badge_type: badgeType,
            date_obtention: new Date().toLocaleDateString('fr-FR'),
            reply_to: "no-reply@manima.com"
        };

        console.log("Tentative d'envoi d'email √†:", email);
        console.log("templateParams envoy√©s :", templateParams);

        emailjs.send("service_wreyh0i", "template_yz8d8qs", templateParams)
            .then(() => console.log("Email de badge envoy√© avec succ√®s"))
            .catch(error => {
                console.error("√âchec envoi email:", {
                    status: error.status,
                    text: error.text
                });
            });
    }
    function fermerListeAvis() {
      document.getElementById("liste-avis-modal").style.display = "none";
    }
    async function voterAvis(nomService, avisId, typeVote) {
    // V√©rifier si l'utilisateur est connect√©
    if (!utilisateurConnecte) {
        // Si non connect√©, demander la connexion Google
        const provider = new firebase.auth.GoogleAuthProvider();
        try {
            const result = await firebase.auth().signInWithPopup(provider);
            utilisateurConnecte = result.user;
            // Une fois connect√©, rappeler la fonction de vote
            voterAvis(nomService, avisId, typeVote);
        } catch (error) {
            alert("Connexion requise pour voter.");
            console.error(error);
        }
        return;
    }

    // Le reste du code existant pour le vote...
    const uidVotant = utilisateurConnecte.uid;
    const avisRef = db.ref(`avis/${nomService}/${avisId}`);

    try {
        // 1. V√©rifier que l'utilisateur ne vote pas pour lui-m√™me
        const avisSnapshot = await avisRef.once('value');
        const avis = avisSnapshot.val();
    
        if (!avis) {
            alert("Cet avis n'existe plus");
            return;
        }

        if (avis.uid === uidVotant) {
            alert("Vous ne pouvez pas voter pour votre propre avis");
            return;
        }

        // 2. Pr√©parer les mises √† jour
        const currentVote = avis.voteurs?.[uidVotant];
        const updates = {};

        if (currentVote === typeVote) {
            // Annuler le vote
            updates[`points${typeVote === 'vert' ? 'Verts' : 'Rouges'}`] = firebase.database.ServerValue.increment(-1);
            updates[`voteurs/${uidVotant}`] = null;
        } else {
            // Nouveau vote ou changement
            if (currentVote) {
                updates[`points${currentVote === 'vert' ? 'Verts' : 'Rouges'}`] = firebase.database.ServerValue.increment(-1);
            }
            updates[`points${typeVote === 'vert' ? 'Verts' : 'Rouges'}`] = firebase.database.ServerValue.increment(1);
            updates[`voteurs/${uidVotant}`] = typeVote;
        }

        // 3. Appliquer les mises √† jour
        await avisRef.update(updates);
    
        // 4. V√©rifier les badges (uniquement si vote vert)
        if (typeVote === 'vert') {
            await verifierBadges(avis.uid);
        }

        // 5. Actualiser l'affichage
        afficherAvis(nomService);

    } catch (error) {
        console.error("Erreur lors du vote:", error);
        alert("Erreur lors du vote: " + error.message);
    }
}

    async function verifierBadges(uidAuteur) {
        try {
            const avisSnapshot = await db.ref('avis').once('value');
            let totalPointsVerts = 0;

            avisSnapshot.forEach(service => {
                service.forEach(avis => {
                    if (avis.val().uid === uidAuteur) {
                        totalPointsVerts += avis.val().pointsVerts || 0;
                    }
                });
            });

            const userRef = db.ref(`utilisateurs/${uidAuteur}`);
            const userSnapshot = await userRef.once('value');
            const userData = userSnapshot.val() || {};

            const updates = {};
            let badgeMoussaillonDebloque = false;
            let badgeCommandantDebloque = false;

            // Moussaillon
            if (totalPointsVerts >= 2 && !userData.badgeMoussaillon) {
                updates.badgeMoussaillon = true;
                updates.dateObtentionBadge = new Date().toISOString();
                badgeMoussaillonDebloque = true;

            }

            // Commandant
            if (totalPointsVerts >= 5 && !userData.badgeCommandant) {
                updates.badgeCommandant = true;
                updates.dateObtentionBadgeCommandant = new Date().toISOString();
                badgeCommandantDebloque = true;
            }

            if (Object.keys(updates).length > 0) {
                await userRef.update(updates);

                // Email apr√®s mise √† jour
                if (badgeMoussaillonDebloque) {
                    const email = userData.email;
                    const nom = userData.displayName || userData.nom || 'Utilisateur';
    
                    if (email && email.includes('@')) {
                        envoyerEmailBadge(email, nom, "Moussaillon");
                    } else {
                        console.warn("Email invalide ou manquant pour l'auteur:", email);
                    }
                }

                // Interface
                if (
                    utilisateurConnecte &&
                    utilisateurConnecte.uid === uidAuteur &&
                    badgeCommandantDebloque
                ) {
                    document.getElementById('chauffeurs-btn').style.display = 'block';
                }
            }
        } catch (error) {
            console.error("Erreur v√©rification badges:", error);
        }
    }
    async function verifierBadgesApresVote(uidAuteur) {
        try {
            // 1. Compter les points verts totaux
            const avisSnapshot = await db.ref('avis').once('value');
            let totalPointsVerts = 0;
        
            avisSnapshot.forEach(service => {
                service.forEach(avis => {
                    if (avis.val().uid === uidAuteur) {
                        totalPointsVerts += avis.val().pointsVerts || 0;
                    }
                });
            });

            // 2. V√©rifier les badges
            const userRef = db.ref(`utilisateurs/${uidAuteur}`);
            const userSnapshot = await userRef.once('value');
            const userData = userSnapshot.val() || {};
        
            const updates = {};
            let shouldSendEmail = false;

            // Badge Moussaillon (3 points verts)
            if (totalPointsVerts >= 2 && !userData.badgeMoussaillon) {
                updates.badgeMoussaillon = true;
                updates.dateObtentionBadge = new Date().toISOString();
                shouldSendEmail = true;
            }

            // Badge Commandant (4 points verts)
            if (totalPointsVerts >= 5 && !userData.badgeCommandant) {
                updates.badgeCommandant = true;
                updates.dateObtentionBadgeCommandant = new Date().toISOString();
            }

            // 3. Appliquer les mises √† jour si n√©cessaire
            if (Object.keys(updates).length > 0) {
                // Seul l'utilisateur peut modifier son propre profil
                if (utilisateurConnecte && utilisateurConnecte.uid === uidAuteur) {
                    await userRef.update(updates);
                
                    // Envoyer email pour badge Moussaillon
                    const email = utilisateurConnecte.email;
                    if (shouldSendEmail && email && email.includes('@')) {
                        envoyerEmailBadge(
                            email,
                            utilisateurConnecte.displayName || 'Utilisateur',
                              "Moussaillon"
                        );
                    } else {
                        console.warn("Email invalide ou manquant pour l'envoi:", email);
                    }
                
                    // Afficher le bouton chauffeurs si commandant
                    if (updates.badgeCommandant) {
                        document.getElementById('chauffeurs-btn').style.display = 'block';
                    }
                }
            }

        } catch (error) {
            console.error("Erreur v√©rification badges:", error);
        }
    }
        // Fonction pour v√©rifier si l'utilisateur est Commandant et afficher le bouton
        function verifierStatutCommandant() {
          console.log("V√©rification statut commandant...");
          if (utilisateurConnecte) {
            console.log("Utilisateur connect√©, UID:", utilisateurConnecte.uid);
            db.ref(`utilisateurs/${utilisateurConnecte.uid}/badgeCommandant`).once('value')
              .then(snapshot => {
                const isCommandant = snapshot.val();
                console.log("Statut commandant:", isCommandant);
                const chauffeursBtn = document.getElementById('chauffeurs-btn');
                if (chauffeursBtn) {
                  console.log("Bouton trouv√©, affichage:", isCommandant ? 'block' : 'none');
                  chauffeursBtn.style.display = isCommandant ? 'block' : 'none';
                } else {
                  console.log("Bouton non trouv√© dans le DOM");
                }
              });
          }
        }
    function afficherChauffeurs() {
  document.getElementById('chauffeurs-modal').style.display = 'block';
  const listeChauffeurs = document.getElementById('liste-chauffeurs');
  
  const chauffeurs = [
    {
      id: "1",
      type: "Taxi Premium",
      vehicule: "Mercedes-Benz Classe E 2022, couleur noire",
      experience: "Depuis 2016",
      telephone: "07.53.01.48.20",
      horaire: "24H/7j",
      langues: "Fran√ßais, Arabe, Anglais, Tarifit, Tamazight",
      zone: "France",
      specialites: "Tous types de trajets (longs trajets, a√©roports, patients m√©dicaux)",
      capacite: "4 places",
      tarifs: {
        nuitAller: "3.06‚Ç¨/Km",
        nuitAllerRetour: "1.53‚Ç¨/Km",
        jourAller: "2.40‚Ç¨/Km", 
        jourAllerRetour: "1.20‚Ç¨/Km"
      }
    },
    {
      id: "2", 
      type: "VTC",
      vehicule: "Toyota Prius +, couleur noire",
      experience: "Depuis 2016",
      telephone: "06.63.78.66.08",
      horaire: "24H/7j",
      langues: "Fran√ßais, Arabe, Anglais, Tarifit, Tamazight",
      zone: "France",
      specialites: "Tous types de trajets (longs/courts trajets, a√©roports, patients m√©dicaux)",
      capacite: "6 places"
    },
    {
      id: "3", 
      type: "Taxi",
      vehicule: "Toyota Prius +, couleur noire",
      experience: "Depuis 2016",
      telephone: "06.69.75.34.52",
      horaire: "24H/7j",
      langues: "Fran√ßais, Tarifit, Arabe, Anglais, Tamazight",
      zone: "France",
      specialites: "Tous types de trajets (longs/courts trajets, a√©roports, patients m√©dicaux)",
      capacite: "6 places"
    },
    // Nouveau chauffeur m√©dical
    {
      id: "4",
      type: "Taxi ",
      telephone: "06.19.76.86.96", // Num√©ro √† adapter
      horaire: "24H/7j sur r√©servation",
      zone: "France"
    }
  ];

  listeChauffeurs.innerHTML = chauffeurs.map(chauffeur => `
    <div class="chauffeur-card">
      <h3>${chauffeur.type}</h3>
      
      ${chauffeur.id === "1" || chauffeur.id === "2" 
        ? `<p style="color: red; font-weight: bold;"></p>` 
        : ''}
      
      ${chauffeur.nom ? `<p><strong>Nom:</strong> ${chauffeur.nom}</p>` : ''}
      ${chauffeur.vehicule ? `<p><strong>V√©hicule:</strong> ${chauffeur.vehicule}</p>` : ''}
      ${chauffeur.experience ? `<p><strong>Exp√©rience:</strong> ${chauffeur.experience}</p>` : ''}
      <p><strong>T√©l√©phone:</strong> ${chauffeur.telephone}</p>
      <p><strong>Horaire:</strong> ${chauffeur.horaire}</p>
      ${chauffeur.capacite ? `<p><strong>Capacit√©:</strong> ${chauffeur.capacite}</p>` : ''}
      ${chauffeur.langues ? `<p><strong>Langues parl√©es:</strong> ${chauffeur.langues}</p>` : ''}
      <p><strong>Zone de couverture:</strong> ${chauffeur.zone}</p>
      ${chauffeur.specialites ? `<p><strong>Sp√©cialit√©s:</strong> ${chauffeur.specialites}</p>` : ''}
      
      ${chauffeur.id === "1" ? `
        <div class="tarifs" style="margin: 10px 0; padding: 10px; background: #f8f8f8; border-radius: 5px;">
          <h4 style="margin-bottom: 5px;">Tarifs :</h4>
          <ul style="margin-top: 5px; padding-left: 20px;">
            <li>Course nuit (aller sans retour): ${chauffeur.tarifs.nuitAller}</li>
            <li>Course nuit (aller-retour): ${chauffeur.tarifs.nuitAllerRetour}</li>
            <li>Course jour (aller sans retour): ${chauffeur.tarifs.jourAller}</li>
            <li>Course jour (aller-retour): ${chauffeur.tarifs.jourAllerRetour}</li>
          </ul>
        </div>
      ` : ''}
      
      <div style="display: flex; gap: 10px; margin-top: 10px;">
        <a href="tel:${chauffeur.telephone.replace(/\./g, '')}" class="call-btn">üìû Appeler</a>
        <button onclick="afficherTousLesAvisChauffeur('${chauffeur.id}')" class="call-btn">üëÄ Voir les avis</button>
      </div>

      <!-- Notation -->
      <div class="notation-chauffeur" style="margin: 15px 0; padding: 10px; background: #f0f0f0; border-radius: 8px;">
        <h4>Notez ce chauffeur :</h4>
        <div class="vote-buttons" style="justify-content: center; font-size: 18px;">
          <span onclick="noterChauffeur('${chauffeur.id}', 'vert')" style="cursor: pointer; margin-right: 15px;">
            üü¢ <span id="chauffeur-points-verts-${chauffeur.id}">0</span>
          </span>
          <span onclick="noterChauffeur('${chauffeur.id}', 'rouge')" style="cursor: pointer;">
            üî¥ <span id="chauffeur-points-rouges-${chauffeur.id}">0</span>
          </span>
        </div>
      </div>

      <!-- Section Avis -->
      <div class="chauffeur-avis-container" style="display: none;" id="chauffeur-avis-container-${chauffeur.id}">
        <h4>Avis sur ce chauffeur</h4>
        <div id="chauffeur-avis-list-${chauffeur.id}" class="chauffeur-avis-list"></div>
        <div class="chauffeur-avis-form">
          <textarea id="chauffeur-avis-text-${chauffeur.id}" placeholder="Votre avis..."></textarea>
          <button onclick="ajouterAvisChauffeur('${chauffeur.id}')">Envoyer l'avis</button>
        </div>
      </div>
    </div>
  `).join('');

  chauffeurs.forEach(chauffeur => {
    chargerNotesChauffeur(chauffeur.id);
    initPointsChauffeur(chauffeur.id);
  });
}

    function fermerChauffeurs() {
      document.getElementById('chauffeurs-modal').style.display = 'none';
    }

    // Appeler cette fonction quand l'utilisateur se connecte
    firebase.auth().onAuthStateChanged((user) => {
      utilisateurConnecte = user;
      if (user) {
        verifierStatutCommandant();
      } else {
        document.getElementById('chauffeurs-btn').style.display = 'none';
      }
    });

    function chargerAvisChauffeur(chauffeurId) {
      const avisContainer = document.getElementById(`chauffeur-avis-list-${chauffeurId}`);
      if (!avisContainer) return;

      avisContainer.innerHTML = '<p>Chargement...</p>';

      db.ref(`avisChauffeurs/${chauffeurId}`).orderByChild('date').once('value')
        .then(snapshot => {
          avisContainer.innerHTML = '';
  
          if (!snapshot.exists()) {
            avisContainer.innerHTML = '<p>Aucun avis pour ce chauffeur.</p>';
            return;
          }

          snapshot.forEach(childSnapshot => {
            const avis = childSnapshot.val();
            const avisElement = document.createElement('div');
            avisElement.className = 'chauffeur-avis-item';
    
            let badgeHtml = '';
            if (utilisateurConnecte) {
              db.ref(`utilisateurs/${avis.userId}/badgeCommandant`).once('value')
                .then(badgeSnapshot => {
                  if (badgeSnapshot.val()) {
                    badgeHtml = '<img src="commandant.png" class="badge-moussaillon" title="Badge Commandant" />';
                  }
                  avisElement.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px;">
                      <img src="https://ui-avatars.com/api/?name=${encodeURIComponent(avis.pseudo || "A")}&background=4CAF50&color=fff&rounded=true" 
                      style="width: 40px; height: 40px; border-radius: 50%;" />
                      <div>
                        <strong>${avis.pseudo || 'Anonyme'}</strong>
                        ${badgeHtml}
                      </div>
                    </div>
                    <p>${avis.text || avis.texte || 'Aucun texte'}</p>
                    <small>${avis.date || 'Date inconnue'}</small>
                  `;
                });
            } else {
              avisElement.innerHTML = `
                <div style="display: flex; align-items: center; gap: 10px;">
                  <img src="https://ui-avatars.com/api/?name=${encodeURIComponent(avis.pseudo || "A")}&background=4CAF50&color=fff&rounded=true" 
                  style="width: 40px; height: 40px; border-radius: 50%;" />
                  <div>
                    <strong>${avis.pseudo || 'Anonyme'}</strong>
                  </div>
                </div>
                <p>${avis.text || avis.texte || 'Aucun texte'}</p>
                <small>${avis.date || 'Date inconnue'}</small>
              `;
            }

            avisContainer.appendChild(avisElement);
          });
        })
        .catch(error => {
          console.error("Erreur de chargement:", error);
          avisContainer.innerHTML = '<p>Erreur de chargement des avis</p>';
        });
    }   

    function ajouterAvisChauffeur(chauffeurId) {
      if (!utilisateurConnecte) {
        alert("Connectez-vous pour poster un avis");
        return;
      }

      const textAvis = document.getElementById(`chauffeur-avis-text-${chauffeurId}`).value.trim();
      if (!textAvis) {
        alert("Veuillez √©crire un avis");
        return;
      }

      const nouvelAvis = {
        texte: textAvis,
        pseudo: utilisateurConnecte.displayName || "Anonyme",
        userId: utilisateurConnecte.uid,
        date: new Date().toLocaleDateString('fr-FR') // Format fran√ßais
      };

      db.ref(`avisChauffeurs/${chauffeurId}`).push(nouvelAvis)
        .then(() => {
          document.getElementById(`chauffeur-avis-text-${chauffeurId}`).value = '';
          chargerAvisChauffeur(chauffeurId);
        })  
        .catch(error => {
          console.error("Erreur:", error);
          alert("Erreur lors de l'envoi de l'avis");
        });
    }
    // Fonction pour initialiser les points si n√©cessaire
    function initPointsChauffeur(chauffeurId) {
      const chauffeurRef = db.ref(`notesChauffeurs/${chauffeurId}`);
  
      return chauffeurRef.once('value').then(snapshot => {
        const data = snapshot.val() || {};
        let updates = {};
    
        // FORCER la r√©initialisation √† 0 si valeur n√©gative
        if (typeof data.pointsVerts !== 'number' || data.pointsVerts < 0) {
          updates.pointsVerts = 0;
        }
        if (typeof data.pointsRouges !== 'number' || data.pointsRouges < 0) {
          updates.pointsRouges = 0;
        }
    
        if (Object.keys(updates).length > 0) {
          console.log('R√©initialisation des points:', updates);
          return chauffeurRef.update(updates);
        }
        return Promise.resolve();
      });
    }

    function noterChauffeur(chauffeurId, typeVote) {
    // V√©rifier si l'utilisateur est connect√©
    if (!utilisateurConnecte) {
        // Si non connect√©, demander la connexion Google
        const provider = new firebase.auth.GoogleAuthProvider();
        firebase.auth().signInWithPopup(provider)
            .then((result) => {
                utilisateurConnecte = result.user;
                // Une fois connect√©, rappeler la fonction de notation
                noterChauffeur(chauffeurId, typeVote);
            })
            .catch((error) => {
                alert("Connexion requise pour noter");
                console.error(error);
            });
        return;
    }

    // Le reste du code existant pour la notation des chauffeurs...
    const uid = utilisateurConnecte.uid;
    const chauffeurRef = db.ref(`notesChauffeurs/${chauffeurId}`);
    const voteRef = db.ref(`votesChauffeurs/${chauffeurId}/${uid}`);

    console.log(`Tentative de vote: ${typeVote}`);

    // 1. INITIALISATION - Corrige les valeurs n√©gatives
    initPointsChauffeur(chauffeurId)
        .then(() => {
            // 2. R√âCUP√âRATION de l'√©tat actuel
            return Promise.all([
                chauffeurRef.once('value'),
                voteRef.once('value')
            ]);
        })
        .then(([chauffeurSnap, voteSnap]) => {
            const currentData = chauffeurSnap.val() || { pointsVerts: 0, pointsRouges: 0 };
            const currentVote = voteSnap.val();
        
            console.log('√âtat actuel:', currentData);

            // 3. PR√âPARATION des mises √† jour
            const updates = {};
            let voteOperation = Promise.resolve();

            if (currentVote === typeVote) {
                // ANNULATION
                console.log('Annulation du vote');
                updates[`points${typeVote === 'vert' ? 'Verts' : 'Rouges'}`] = 
                    firebase.database.ServerValue.increment(-1);
                voteOperation = voteRef.remove();
            } else {
                // NOUVEAU VOTE ou CHANGEMENT
                if (currentVote) {
                    updates[`points${currentVote === 'vert' ? 'Verts' : 'Rouges'}`] = 
                        firebase.database.ServerValue.increment(-1);
                }
                updates[`points${typeVote === 'vert' ? 'Verts' : 'Rouges'}`] = 
                    firebase.database.ServerValue.increment(1);
                voteOperation = voteRef.set(typeVote);
            }

            // 4. APPLICATION des mises √† jour
            return Promise.all([
                chauffeurRef.update(updates),
                voteOperation
            ]);
        })
        .then(() => {
            console.log('Mise √† jour r√©ussie');
            // 5. ACTUALISATION de l'affichage
            return chargerNotesChauffeur(chauffeurId);
        })
        .catch(error => {
            console.error('Erreur:', error);
            alert("Erreur: " + error.message);
        });
}

    // Version optimis√©e de chargerNotesChauffeur
    function chargerNotesChauffeur(chauffeurId) {
      const chauffeurRef = db.ref(`notesChauffeurs/${chauffeurId}`);
  
      return chauffeurRef.once('value').then(snapshot => {
        const data = snapshot.val() || { pointsVerts: 0, pointsRouges: 0 };
    
        console.log('Nouvelles valeurs:', {
          verts: data.pointsVerts,
          rouges: data.pointsRouges
        });

        const vertsElem = document.getElementById(`chauffeur-points-verts-${chauffeurId}`);
        const rougesElem = document.getElementById(`chauffeur-points-rouges-${chauffeurId}`);

        if (vertsElem) {
          vertsElem.textContent = data.pointsVerts || 0;
          console.log('Affichage vert mis √† jour:', vertsElem.textContent);
        }
        if (rougesElem) {
          rougesElem.textContent = data.pointsRouges || 0;
          console.log('Affichage rouge mis √† jour:', rougesElem.textContent);
        }
      });
    }

    // Fonction pour voter sur un avis de chauffeur
    function voterAvisChauffeur(chauffeurId, avisId, typeVote) {
      // V√©rifier si l'utilisateur est connect√©
    if (!utilisateurConnecte) {
        const provider = new firebase.auth.GoogleAuthProvider();
        firebase.auth().signInWithPopup(provider)
            .then((result) => {
                utilisateurConnecte = result.user;
                voterAvisChauffeur(chauffeurId, avisId, typeVote);
            })
            .catch((error) => {
                alert("Connexion requise pour voter.");
                console.error(error);
            });
        return;
    }

      const avisRef = db.ref(`avisChauffeurs/${chauffeurId}/${avisId}`);
      const uid = utilisateurConnecte.uid;

      avisRef.once('value').then(snapshot => {
        const avis = snapshot.val();
        if (!avis) return;

        if (avis.uid === uid) {
          alert("Vous ne pouvez pas voter pour votre propre avis.");
          return;
        }

        const currentVote = avis.voteurs?.[uid];
        let updates = {};

        if (typeof avis.pointsVerts !== 'number') updates.pointsVerts = 0;
        if (typeof avis.pointsRouges !== 'number') updates.pointsRouges = 0;

        if (!currentVote) {
          // Nouveau vote
          updates[`points${typeVote === 'vert' ? 'Verts' : 'Rouges'}`] = firebase.database.ServerValue.increment(1);
          updates[`voteurs/${uid}`] = typeVote;
        } else if (currentVote === typeVote) {
          // M√™me vote ‚Üí annule
          updates[`points${typeVote === 'vert' ? 'Verts' : 'Rouges'}`] = firebase.database.ServerValue.increment(-1);
          updates[`voteurs/${uid}`] = null;
        } else {
          // Changement de vote
          updates[`points${currentVote === 'vert' ? 'Verts' : 'Rouges'}`] = firebase.database.ServerValue.increment(-1);
          updates[`points${typeVote === 'vert' ? 'Verts' : 'Rouges'}`] = firebase.database.ServerValue.increment(1);
          updates[`voteurs/${uid}`] = typeVote;
        }

        return avisRef.update(updates);
      })
      .then(() => chargerAvisChauffeur(chauffeurId))
      .catch(error => {
        console.error("Erreur lors du vote:", error);
        alert("Une erreur est survenue lors de votre vote.");
      });
    }
    function afficherTousLesAvisChauffeur(chauffeurId) {
      const avisContainer = document.getElementById(`chauffeur-avis-container-${chauffeurId}`);
      if (avisContainer.style.display === 'none') {
        avisContainer.style.display = 'block';
        chargerAvisChauffeur(chauffeurId);
      } else {
        avisContainer.style.display = 'none';
      }
    }

    function fermerTousLesAvis() {
      document.getElementById('tous-les-avis-modal').style.display = 'none';
    }


    // Fonctions pour le formulaire de commerce
    function afficherFormulaireCommerce() {
      // G√©n√©rer les champs horaires si pas d√©j√† fait
      if (document.getElementById("commerce-horaires-container").children.length === 0) {
        const jours = [
          { nom: 'Lundi', emoji: 'üìÖ' },
          { nom: 'Mardi', emoji: 'üìÖ' },
          { nom: 'Mercredi', emoji: 'üìÖ' },
          { nom: 'Jeudi', emoji: 'üìÖ' },
          { nom: 'Vendredi', emoji: 'üìÖ' },
          { nom: 'Samedi', emoji: 'üìÖ' },
          { nom: 'Dimanche', emoji: 'üö´' }
        ];
        const container = document.getElementById("commerce-horaires-container");
    
        jours.forEach(jour => {
          const div = document.createElement('div');
          div.innerHTML = `
            <label for="commerce-horaire-${jour.nom.toLowerCase()}">
              ${jour.emoji} ${jour.nom}
            </label>
            <input type="text" id="commerce-horaire-${jour.nom.toLowerCase()}" 
                   placeholder="${jour.nom === 'Dimanche' ? 'Ferm√©' : '9h-12h / 14h-19h'}">
          `;
          container.appendChild(div);
        });
      }
  
      document.getElementById("commerce-modal").style.display = "block";
    }

    function fermerCommerceModal() {
      document.getElementById("commerce-modal").style.display = "none";
    }

    // Gestion de la soumission du formulaire
    document.getElementById("commerce-form").addEventListener("submit", async function(e) {
      e.preventDefault();
  
      if (!document.getElementById("commerce-cgu").checked) {
        alert("Veuillez accepter les CGU");
        return;
      }

      // R√©cup√©rer les coordonn√©es GPS (g√©ocodage)
      const adresseComplete = `${document.getElementById("commerce-adresse").value}, ${document.getElementById("commerce-codepostal").value} ${document.getElementById("commerce-ville").value}`;
      let coords = null;
  
      if (document.getElementById("commerce-geoloc-auto").checked) {
        try {
          const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(adresseComplete)}`);
          const data = await response.json();
          if (data.length > 0) {
            coords = [parseFloat(data[0].lat), parseFloat(data[0].lon)];
          }
        } catch (error) {
          console.error("Erreur de g√©ocodage:", error);
        }
      }

      // R√©cup√©rer les horaires
      const jours = ['lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi', 'dimanche'];
      const horaires = jours.reduce((acc, jour) => {
        acc[jour] = document.getElementById(`commerce-horaire-${jour}`).value || "";
        return acc;
      }, {});

      // Cr√©er l'objet GeoJSON Feature
      const feature = {
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: coords || [0, 0] // Si pas de g√©oloc, sera mis √† jour manuellement
        },
        properties: {
          name: document.getElementById("commerce-nom").value,
          amenity: document.getElementById("commerce-categorie").value,
          description: document.getElementById("commerce-description").value,
          address: adresseComplete,
          phone: document.getElementById("commerce-telephone").value,
          email: document.getElementById("commerce-email").value,
          whatsapp: document.getElementById("commerce-whatsapp").value,
          opening_hours: {
            ouvert_7j7: document.getElementById("commerce-ouvert-7j7").checked,
            sur_rdv: document.getElementById("commerce-sur-rdv").checked,
            details: horaires
          },
          gerant: {
            nom: document.getElementById("commerce-nom-gerant").value,
            email: document.getElementById("commerce-email-gerant").value
          },
          statut: "en_attente",
          date_ajout: new Date().toISOString(),
          added_by: utilisateurConnecte ? utilisateurConnecte.uid : "anonymous"
        }
      };

      try {
        // Enregistrer dans Firebase
        const newCommerceRef = db.ref('commerces').push();
        await newCommerceRef.set(feature);
    
       
        alert("Votre commerce a √©t√© soumis avec succ√®s ! Il sera publi√© apr√®s validation.");
        fermerCommerceModal();
        document.getElementById("commerce-form").reset();
    
        // Recharger les donn√©es sur la carte
        if (allFeatures) {
          allFeatures.push(feature);
          afficherServices("");
        }
      } catch (error) {
        console.error("Erreur lors de l'enregistrement:", error);
        alert("Une erreur est survenue lors de l'enregistrement.");
      }
    });
    // Fonctions pour le QR Code
    let qrCodeActuel = null;
    let lienPartageActuel = '';

    function afficherQRModal(nomLieu, lat, lng) {
  // Cr√©er un lien court POUR LA PRODUCTION (remplace localhost par ton vrai domaine)
  const domaine = window.location.origin; // Utilise le domaine actuel
  const lienComplet = `${domaine}?lieu=${encodeURIComponent(nomLieu)}&lat=${lat}&lng=${lng}`;
  
  lienPartageActuel = lienComplet;

  // Afficher le lien dans la modal
  document.getElementById('lien-partage').textContent = lienComplet;

  // G√©n√©rer le QR code
  const qrCodeContainer = document.getElementById('qr-code-container');
  qrCodeContainer.innerHTML = '<div style="text-align:center; font-weight:bold; margin-bottom:10px;">Trouvez-nous ici :</div>';

  if (typeof QRCode !== 'undefined') {
    qrCodeActuel = new QRCode(qrCodeContainer, {
      text: lienComplet,
      width: 200,
      height: 200,
      colorDark: "#000000",
      colorLight: "#ffffff",
      correctLevel: QRCode.CorrectLevel.H
    });
  } else {
    qrCodeContainer.innerHTML = '<p>Erreur de g√©n√©ration du QR Code</p>';
    return;
  }

  document.getElementById('qr-modal').style.display = 'block';
}

    function fermerQRModal() {
      document.getElementById('qr-modal').style.display = 'none';
    }

    function telechargerQRCode() {
  if (!qrCodeActuel) {
    alert("QR Code non disponible");
    return;
  }

  const container = document.querySelector('#qr-code-container');
  const canvas = container.querySelector('canvas');
  
  if (!canvas) {
    alert("Erreur : Canvas non trouv√©");
    return;
  }

  try {
    // Cr√©er un canvas BEAUCOUP plus grand avec des marges importantes
    const newCanvas = document.createElement('canvas');
    const scale = 2;
    const margin = 80; // Espace blanc important
    
    // Dimensions avec g√©n√©reuses marges blanches
    newCanvas.width = (canvas.width + margin * 2) * scale;
    newCanvas.height = (canvas.height + margin * 2 + 120) * scale;
    
    const ctx = newCanvas.getContext('2d');
    
    // Fond blanc pour toute la zone
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);
    
    // Charger le logo
    const logo = new Image();
    logo.onload = function() {
      // Logo en haut avec marge
      const logoSize = 40 * scale;
      const logoX = (newCanvas.width - logoSize) / 2;
      const logoY = margin * 0.5;
      
      ctx.drawImage(logo, logoX, logoY, logoSize, logoSize);
      
      // Texte sous le logo
      ctx.fillStyle = '#4CAF50';
      ctx.font = `bold ${16 * scale}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('Trouvez-nous ici sur', newCanvas.width/2, logoY + logoSize + (20 * scale));
      
      // Texte "Manimap"
      ctx.font = `bold ${20 * scale}px Arial`;
      ctx.fillText('Manimap', newCanvas.width/2, logoY + logoSize + (45 * scale));
      
      // Dessiner le QR Code AU CENTRE avec marges blanches
      const qrX = margin * scale;
      const qrY = logoY + logoSize + (70 * scale); // Position apr√®s le texte
      const qrSize = canvas.width * scale;
      
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(canvas, qrX, qrY, qrSize, qrSize);
      
      // Ajouter une bordure subtile autour du QR Code
      ctx.strokeStyle = '#e0e0e0';
      ctx.lineWidth = 2 * scale;
      ctx.strokeRect(qrX - (5 * scale), qrY - (5 * scale), qrSize + (10 * scale), qrSize + (10 * scale));
      
      // T√©l√©charger
      downloadFinalImage(newCanvas);
    };
    
    logo.onerror = function() {
      // Fallback si le logo ne charge pas
      console.log("Logo non trouv√©, utilisation du texte uniquement");
      drawTextOnlyVersionWithMargins(ctx, newCanvas, canvas, scale, margin);
    };
    
    logo.src = 'icons/icone-manima.png';
    
  } catch (error) {
    console.error("Erreur t√©l√©chargement QR:", error);
    alert("Erreur lors du t√©l√©chargement. Essayez de prendre une capture d'√©cran.");
  }
}

// Version de secours avec marges
function drawTextOnlyVersionWithMargins(ctx, newCanvas, canvas, scale, margin) {
  // Fond blanc
  ctx.fillStyle = 'white';
  ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);
  
  // Texte principal en haut
  ctx.fillStyle = '#4CAF50';
  ctx.font = `bold ${14 * scale}px Arial`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('Trouvez-nous ici sur', newCanvas.width/2, margin * 0.7);
  
  // Texte "Manimap" en plus gros
  ctx.font = `bold ${18 * scale}px Arial`;
  ctx.fillText('MANIMAP', newCanvas.width/2, margin * 0.7 + (25 * scale));
  
  // Dessiner le QR Code avec marges
  const qrX = margin * scale;
  const qrY = margin * scale + (40 * scale);
  const qrSize = canvas.width * scale;
  
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(canvas, qrX, qrY, qrSize, qrSize);
  
  // Bordure subtile
  ctx.strokeStyle = '#e0e0e0';
  ctx.lineWidth = 2 * scale;
  ctx.strokeRect(qrX - (5 * scale), qrY - (5 * scale), qrSize + (10 * scale), qrSize + (10 * scale));
  
  downloadFinalImage(newCanvas);
}

// Fonction pour finaliser le t√©l√©chargement (conservez celle que vous avez d√©j√†)
function downloadFinalImage(canvas) {
  const lien = document.createElement('a');
  
  if (navigator.share) {
    canvas.toBlob(function(blob) {
      const file = new File([blob], "qr-code-manima.png", { type: "image/png" });
      navigator.share({
        files: [file],
        title: 'QR Code Manimap',
        text: 'Partagez ce QR Code'
      }).catch(err => {
        console.log('Annulation du partage:', err);
        fallbackDownload(canvas);
      });
    });
  } else {
    fallbackDownload(canvas);
  }
}

// Fonction fallback pour le t√©l√©chargement (conservez celle que vous avez d√©j√†)
function fallbackDownload(canvas) {
  const lien = document.createElement('a');
  lien.href = canvas.toDataURL('image/png');
  lien.download = 'qr-code-manima.png';
  
  // M√©thode plus fiable pour mobile
  document.body.appendChild(lien);
  lien.click();
  document.body.removeChild(lien);
}   

    function copierLienPartage() {
      navigator.clipboard.writeText(lienPartageActuel)
        .then(() => alert('Lien copi√© dans le presse-papiers !'))
        .catch(err => console.error('Erreur lors de la copie :', err));
    }
    // Au chargement de la page, v√©rifier les param√®tres URL
    // VERSION ULTRA-RAPIDE - Remplace ta fonction verifierParametresURL
// VERSION ULTRA-RAPIDE - Fonction pour v√©rifier les param√®tres URL
// VERSION STABLE - Gestion automatique des popups depuis URL
// REMPLACE ta fonction verifierParametresURL par cette version ULTRA-RENFORC√âE
// REMPLACE compl√®tement ta fonction verifierParametresURL par ceci :
function verifierParametresURL() {
  const urlParams = new URLSearchParams(window.location.search);
  const nomLieu = urlParams.get("lieu");
  const lat = parseFloat(urlParams.get("lat"));
  const lng = parseFloat(urlParams.get("lng"));

  if (nomLieu && lat && lng) {
    console.log("üöÄ PARAM√àTRES URL D√âTECT√âS - OUVERTURE DIRECTE:", nomLieu, lat, lng);

    // 1. CENTRER ET ZOOMER FORTEMENT
    map.setView([lat, lng], 19, {
      animate: true,
      duration: 0.5
    });

    // 2. ATTENDRE que tout soit charg√©
    const attenteChargement = setInterval(() => {
      if (allFeatures && allFeatures.length > 0 && clusterLayer) {
        clearInterval(attenteChargement);
        console.log("‚úÖ Donn√©es pr√™tes ‚Äî OUVERTURE DIRECTE IMM√âDIATE");
        
        // 3. OUVRIR DIRECTEMENT sans attendre
        ouvrirPopupClusterSafe(nomLieu, lat, lng);
      }
    }, 300);
  }
}
function ouvrirPopupClusterSafe(nomLieu, lat, lng, tentative = 0) {
  console.log(`üß≠ Tentative ${tentative + 1} pour ouvrir le popup cluster-safe de "${nomLieu}"`);

  if (!clusterLayer) return console.warn("‚ö†Ô∏è clusterLayer pas encore pr√™t");

  const positionCible = L.latLng(lat, lng);
  let markerCible = null;
  let meilleureDistance = Infinity;

  // Trouver le bon marqueur
  clusterLayer.eachLayer(marker => {
    if (!marker.getLatLng) return;
    const popupContent = marker.getPopup()?.getContent() || '';
    const nomDansPopup = popupContent.match(/<b>(.*?)<\/b>/)?.[1] || '';
    const distance = positionCible.distanceTo(marker.getLatLng());
    if (nomDansPopup && nomDansPopup.toLowerCase().includes(nomLieu.toLowerCase())) {
      if (distance < meilleureDistance) {
        meilleureDistance = distance;
        markerCible = marker;
      }
    }
  });

  if (!markerCible) {
    if (tentative < 10) {
      console.log("‚è≥ Aucun marqueur trouv√©, r√©essai dans 400ms...");
      return setTimeout(() => ouvrirPopupClusterSafe(nomLieu, lat, lng, tentative + 1), 400);
    }
    return console.error("‚ùå Aucun marqueur correspondant trouv√©");
  }

  const parentCluster = clusterLayer.getVisibleParent(markerCible);

  // Si cluster ne peut pas se d√©plier (plusieurs marqueurs √† la m√™me position)
  if (parentCluster && parentCluster._childCount > 1) {
    console.log("‚ö†Ô∏è Cluster ind√©pliable d√©tect√© ‚Äî ouverture via marqueur temporaire");

    const popupContent = markerCible.getPopup()?.getContent() || `<b>${nomLieu}</b>`;

    // Cr√©ation d‚Äôun faux marqueur invisible
    const fauxMarker = L.marker(positionCible, { opacity: 0, interactive: false }).addTo(map);
    fauxMarker.bindPopup(popupContent);

    map.setView(positionCible, 20, { animate: true });
    setTimeout(() => {
      fauxMarker.openPopup();
      console.log("üéØ Popup affich√© via faux marqueur !");
      // Supprime le faux marqueur apr√®s 5s
      setTimeout(() => map.removeLayer(fauxMarker), 5000);
    }, 500);

    return;
  }

  // Si le marqueur est visible
  if (!parentCluster || parentCluster === markerCible) {
    console.log("üìç Marqueur d√©j√† visible ‚Äî ouverture directe");
    map.setView(markerCible.getLatLng(), 19, { animate: true });
    setTimeout(() => markerCible.openPopup(), 400);
    return;
  }

  // Sinon : spiderfy classique
  console.log("üï∑Ô∏è Cluster spiderfy normal");
  parentCluster.once('spiderfied', () => {
    setTimeout(() => markerCible.openPopup(), 300);
  });
  parentCluster.spiderfy();
}

// NOUVELLE FONCTION - OUVERTURE DIRECTE SANS CLIC
function ouvrirPopupDirect(nomLieu, lat, lng, tentative = 0) {
  console.log(`üéØ OUVERTURE DIRECTE - Tentative ${tentative + 1} pour "${nomLieu}"`);

  // FORCER la fermeture de tous les popups d'abord
  map.closePopup();

  const positionCible = L.latLng(lat, lng);
  let meilleurMarqueur = null;
  let meilleureDistance = Infinity;

  // üî• RECHERCHE ULTRA-PR√âCISE du bon marqueur
  clusterLayer.eachLayer(marker => {
    if (!marker.getLatLng) return;
    
    const markerPos = marker.getLatLng();
    const popupContent = marker.getPopup()?.getContent() || '';
    const nomDansPopup = popupContent.match(/<b>(.*?)<\/b>/)?.[1] || '';
    const distance = positionCible.distanceTo(markerPos);

    // V√©rifier la correspondance EXACTE du nom
    const nomCorrespond = nomDansPopup.toLowerCase().includes(nomLieu.toLowerCase());
    
    if (nomCorrespond && distance < 30) { // Distance tr√®s courte
      if (distance < meilleureDistance) {
        meilleureDistance = distance;
        meilleurMarqueur = marker;
      }
    }
  });

  if (meilleurMarqueur) {
    console.log("‚úÖ Marqueur exact trouv√© - OUVERTURE DIRECTE");
    ouvrirMarqueurDirectement(meilleurMarqueur);
    return;
  }

  // üîÑ SI PAS TROUV√â - Recherche √©largie
  console.log("üîÑ Recherche √©largie...");
  clusterLayer.eachLayer(marker => {
    if (!marker.getLatLng) return;
    
    const markerPos = marker.getLatLng();
    const distance = positionCible.distanceTo(markerPos);
    
    if (distance < 50) { // Distance un peu plus large
      if (distance < meilleureDistance) {
        meilleureDistance = distance;
        meilleurMarqueur = marker;
      }
    }
  });

  if (meilleurMarqueur) {
    console.log("‚úÖ Marqueur proche trouv√© - OUVERTURE DIRECTE");
    ouvrirMarqueurDirectement(meilleurMarqueur);
    return;
  }

  // ‚ùå SI TOUJOURS PAS TROUV√â
  if (tentative < 10) {
    console.log(`‚è≥ Tentative ${tentative + 1} √©chou√©e - Nouvel essai dans 500ms`);
    setTimeout(() => ouvrirPopupDirect(nomLieu, lat, lng, tentative + 1), 500);
  } else {
    console.error("‚ùå Impossible de trouver le marqueur apr√®s 10 tentatives");
  }
}

// FONCTION CRITIQUE - Ouvre le marqueur DIRECTEMENT
function ouvrirMarqueurDirectement(marker) {
  console.log("üî• OUVERTURE DIRECTE DU MARQUEUR");

  // 1. Fermer tous les popups
  map.closePopup();

  // 2. V√©rifier si le marqueur est dans un cluster
  const parentCluster = clusterLayer.getVisibleParent(marker);
  
  if (parentCluster && parentCluster !== marker) {
    console.log("üï∑Ô∏è Marqueur dans cluster - D√âVELOPPEMENT AUTOMATIQUE");
    
    // üî• D√âVELOPPER LE CLUSTER AUTOMATIQUEMENT
    parentCluster.spiderfy();
    
    // Attendre que le cluster soit d√©velopp√©
    parentCluster.once('spiderfied', function() {
      console.log("‚úÖ Cluster d√©velopp√© - OUVERTURE POPUP");
      
      // Petit d√©lai pour √™tre s√ªr
      setTimeout(() => {
        // FORCER l'ouverture du popup
        if (marker.getPopup()) {
          marker.openPopup();
          console.log("üéâ POPUP OUVERT DIRECTEMENT !");
          
          // Protection contre la fermeture accidentelle
          protegerPopupFort(marker);
        }
      }, 400);
    });
    
  } else {
    // Marqueur d√©j√† visible - OUVERTURE DIRECTE
    console.log("üìç Marqueur visible - OUVERTURE IMM√âDIATE");
    setTimeout(() => {
      if (marker.getPopup()) {
        marker.openPopup();
        console.log("üéâ POPUP OUVERT DIRECTEMENT !");
        protegerPopupFort(marker);
      }
    }, 200);
  }
}



// NOUVELLE FONCTION - Ouvre le popup m√™me dans les clusters denses
function ouvrirPopupForce(nomLieu, lat, lng, tentative = 0) {
  console.log(`üéØ FORCE OUVERTURE - Tentative ${tentative + 1} pour "${nomLieu}"`);

  const positionCible = L.latLng(lat, lng);
  let marqueursTrouves = [];

  // üî• RECHERCHE AGGRESSIVE de tous les marqueurs proches
  clusterLayer.eachLayer(marker => {
    if (!marker.getLatLng) return;
    
    const markerPos = marker.getLatLng();
    const popupContent = marker.getPopup()?.getContent() || '';
    const nomDansPopup = popupContent.match(/<b>(.*?)<\/b>/)?.[1] || '';
    const distance = positionCible.distanceTo(markerPos);

    // Recherche plus large pour trouver le bon service
    if (nomDansPopup.toLowerCase().includes(nomLieu.toLowerCase()) || 
        distance < 50) { // Distance plus large
      marqueursTrouves.push({
        marker: marker,
        distance: distance,
        nom: nomDansPopup
      });
    }
  });

  console.log(`üìç Marqueurs trouv√©s: ${marqueursTrouves.length}`, marqueursTrouves);

  if (marqueursTrouves.length === 0) {
    if (tentative < 8) { // Plus de tentatives
      console.log("‚è≥ Aucun marqueur trouv√©, nouvelle tentative...");
      return setTimeout(() => ouvrirPopupForce(nomLieu, lat, lng, tentative + 1), 500);
    } else {
      console.error("‚ùå Aucun marqueur correspondant trouv√© apr√®s plusieurs essais.");
      return;
    }
  }

  // Trier par distance et correspondance du nom
  marqueursTrouves.sort((a, b) => {
    // Priorit√© au nom exact
    const exactMatchA = a.nom.toLowerCase() === nomLieu.toLowerCase();
    const exactMatchB = b.nom.toLowerCase() === nomLieu.toLowerCase();
    
    if (exactMatchA && !exactMatchB) return -1;
    if (!exactMatchA && exactMatchB) return 1;
    
    // Sinon par distance
    return a.distance - b.distance;
  });

  const markerCible = marqueursTrouves[0].marker;
  console.log("üéØ Marqueur cible s√©lectionn√©:", markerCible.getPopup()?.getContent()?.substring(0, 50));

  // üî• FORCER LA FERMETURE DE TOUS LES POPUPS
  map.closePopup();

  // V√©rifier si le marqueur est dans un cluster
  const parentCluster = clusterLayer.getVisibleParent(markerCible);
  
  if (parentCluster && parentCluster !== markerCible) {
    console.log("üï∑Ô∏è Marqueur dans un cluster ‚Äî d√©veloppement forc√©...");
    
    // D√©velopper le cluster
    parentCluster.once('spiderfied', function() {
      console.log("‚úÖ Cluster d√©velopp√© ‚Äî ouverture du popup...");
      setTimeout(() => {
        // R√©-ouvrir le popup apr√®s d√©veloppement
        markerCible.openPopup();
        protegerPopup(markerCible);
      }, 300);
    });
    
    parentCluster.spiderfy();
    
    // Plan B: Si le spiderfy ne fonctionne pas
    setTimeout(() => {
      if (!markerCible.getPopup()?.isOpen()) {
        console.log("üîÑ Spiderfy √©chou√© ‚Äî ouverture directe...");
        markerCible.openPopup();
        protegerPopup(markerCible);
      }
    }, 1000);
    
  } else {
    // Marqueur d√©j√† visible
    console.log("üìç Marqueur d√©j√† visible ‚Äî ouverture directe...");
    setTimeout(() => {
      markerCible.openPopup();
      protegerPopup(markerCible);
    }, 200);
  }
}



function ouvrirPopupRapide(nomLieu, lat, lng, tentative = 0) {
  console.log(`üéØ Tentative ${tentative + 1} ‚Äî recherche pr√©cise pour "${nomLieu}"`);

  const positionCible = L.latLng(lat, lng);
  let marqueursProches = [];

  // üîç Recherche des marqueurs proches
  clusterLayer.eachLayer(marker => {
    if (!marker.getLatLng) return;
    const markerPos = marker.getLatLng();
    const popupContent = marker.getPopup()?.getContent() || '';
    const nomDansPopup = popupContent.match(/<b>(.*?)<\/b>/)?.[1] || '';
    const distance = positionCible.distanceTo(markerPos);

    if (nomDansPopup.toLowerCase().includes(nomLieu.toLowerCase()) && distance < 25) {
      marqueursProches.push(marker);
    }
  });

  if (marqueursProches.length === 0) {
    if (tentative < 5) {
      console.log("‚è≥ Aucun marqueur trouv√©, nouvelle tentative...");
      return setTimeout(() => ouvrirPopupRapide(nomLieu, lat, lng, tentative + 1), 400);
    } else {
      return console.warn("‚ùå Aucun marqueur correspondant trouv√© apr√®s plusieurs essais.");
    }
  }

  // üï∑Ô∏è Si les marqueurs sont regroup√©s dans un cluster
  const parentCluster = clusterLayer.getVisibleParent(marqueursProches[0]);
  if (parentCluster && parentCluster !== marqueursProches[0] && parentCluster.spiderfy) {
    console.log("üï∑Ô∏è Cluster d√©tect√© ‚Äî ouverture en √©toile en cours‚Ä¶");
    parentCluster.once("spiderfied", () => {
      setTimeout(() => {
        console.log("‚úÖ Spiderfy termin√© ‚Äî recherche du bon marqueur‚Ä¶");
        ouvrirPopupRapide(nomLieu, lat, lng, tentative + 1);
      }, 400);
    });
    parentCluster.spiderfy();
    return;
  }

  // ‚úÖ Si un seul marqueur ou cluster d√©j√† ouvert
  const markerCible = marqueursProches[0];
  console.log("üìç Marqueur trouv√©:", markerCible.getPopup()?.getContent()?.substring(0, 50));

  map.closePopup();

  // üîÅ Attendre que tout soit pr√™t avant ouverture
  setTimeout(() => {
    markerCible.openPopup();
    protegerPopup(markerCible);
    console.log("üéâ Popup ouvert avec succ√®s !");
  }, 250);
}

function attendreOuverturePopup(marker, tentative = 0) {
  let essais = 0;
  const popupNom = marker.getPopup()?.getContent()?.match(/<b>(.*?)<\/b>/)?.[1];

  const interval = setInterval(() => {
    essais++;
    const popupOuvert = marker.getPopup()?.isOpen();

    if (map.hasLayer(marker)) {
      clearInterval(interval);
      console.log(`üì¨ Ouverture du popup pour "${popupNom}"`);
      setTimeout(() => {
        marker.openPopup();
        protegerPopup(marker);
      }, 200); // D√©lai l√©ger pour √©viter conflit d‚Äôanimation
    } else if (essais > 15) {
      clearInterval(interval);
      if (tentative < 3) {
        console.warn("‚ö†Ô∏è Marqueur encore masqu√©, nouvelle tentative...");
        ouvrirPopupRapide(popupNom, marker.getLatLng().lat, marker.getLatLng().lng, tentative + 1);
      } else {
        console.error("‚ùå Impossible d‚Äôafficher le popup apr√®s plusieurs essais");
      }
    }
  }, 200);
}



function trouverMarqueurParNomEtPosition(nomRecherche, lat, lng) {
  let meilleurMarqueur = null;
  let meilleureDistance = Infinity;

  clusterLayer.eachLayer(marker => {
    if (!marker.getLatLng) return;
    const markerLatLng = marker.getLatLng();
    const distance = map.distance(markerLatLng, [lat, lng]);
    const popupContent = marker.getPopup()?.getContent() || "";
    const nomDansPopup = popupContent.match(/<b>(.*?)<\/b>/)?.[1];
    if (nomDansPopup && nomDansPopup.trim().toLowerCase().includes(nomRecherche.trim().toLowerCase())) {
      if (distance < 50 && distance < meilleureDistance) {
        meilleureDistance = distance;
        meilleurMarqueur = marker;
      }
    }
  });

  return meilleurMarqueur;
}

// V√©rification automatique
document.addEventListener("DOMContentLoaded", () => {
  setTimeout(verifierParametresURL, 300);
});

map.whenReady(() => {
  setTimeout(verifierParametresURL, 500);
});
    


    function logError(type, message) {
      firebase.firestore().collection("logs").add({
      type: type,
      message: message,
      timestamp: firebase.firestore.FieldValue.serverTimestamp()
      }).catch(err => console.error("Erreur lors du log :", err));
    }

    function afficherStreetView(lat, lng) {
  const panoUrl = `https://www.google.com/maps/embed?pb=!4v0!6m8!1m7!1sCAoSLEFGMVFpcE1TRWxJazhiVnFzRzVvYXhtem1hd1Q2eVY4amE1bEVVTmN5a3hO!2m2!1d${lat}!2d${lng}!3f0!4f0!5f0.7820865974627469`;
  
  const container = document.getElementById('streetview-embed-container');
  
  // Cr√©e l'iframe
  const iframe = document.createElement('iframe');
  iframe.src = panoUrl;
  iframe.style.width = '100%';
  iframe.style.height = '100%';
  iframe.style.border = 'none';
  iframe.allowFullscreen = true;

  // Bouton fermer
  const closeBtn = document.createElement('div');
  closeBtn.textContent = '√ó';
  closeBtn.style = 'position:absolute;top:10px;right:20px;font-size:30px;color:white;cursor:pointer;';
  closeBtn.onclick = fermerStreetView;

  // Vider container et ajouter iframe + bouton fermer
  container.innerHTML = '';
  container.appendChild(iframe);
  container.appendChild(closeBtn);
  container.style.display = 'block';

  // Timeout de 5 secondes pour v√©rifier si l'iframe charge
  let iframeLoaded = false;
  iframe.onload = () => {
    iframeLoaded = true;
  };

  setTimeout(() => {
    if (!iframeLoaded) {
      // Affiche message d'urgence avec lien
      container.innerHTML = `
        <div style="color:white; padding:20px; text-align:center; font-size:18px;">
          Street View temporairement indisponible.<br>
          <a href="https://www.google.com/maps/@${lat},${lng},streetview" target="_blank" style="color:#00aaff; text-decoration:underline;">
            Cliquez ici pour ouvrir dans Google Maps.
          </a>
        </div>
        <div class="close-streetview" onclick="fermerStreetView()" style="position:absolute;top:10px;right:20px;font-size:30px;color:white;cursor:pointer; cursor:pointer;">√ó</div>
      `;
    }
  }, 5000); // 5 secondes d'attente
}



// AJOUTEZ CES FONCTIONS MANQUANTES

// Fonction manquante
async function testMeteoIntegration() {
  console.log("üß™ Test des donn√©es m√©t√©o DIRECTES...");
  const weather = await getLilleWeather();
  
  console.log("‚úÖ R√©sultat:", {
    source: weather.realData ? "API R√©elle" : "Simulation",
    temp√©rature: `${weather.temp}¬∞C`,
    recommandation: weather.recommendation,
    pluie: weather.raining ? "Oui ‚òîÔ∏è" : "Non ‚òÄÔ∏è",
    temps: weather.weather
  });
}

// Fonction de test m√©t√©o
async function testMeteo() {
  console.log("üå§Ô∏è Test des donn√©es m√©t√©o...");
  const weather = await getLilleWeather();
  
  if (weather.error) {
    console.error("‚ùå √âchec:", weather.error);
  } else {
    console.log("‚úÖ Succ√®s - Recommandation:", weather.recommendation);
    console.log(`üå°Ô∏è Temp√©rature: ${weather.temp}¬∞C`);
    console.log(`‚òîÔ∏è Pluie: ${weather.raining ? 'Oui' : 'Non'}`);
  }
}

// CORRECTION DE LA FONCTION M√âT√âO PRINCIPALE
// Syst√®me de cache pour √©conomiser les appels API
let weatherCache = {
  data: null,
  timestamp: 0,
  duration: 10 * 60 * 1000 // 10 minutes de cache
};

async function getLilleWeather() {
  // COMPTER LES APPELS M√âT√âO
  if (window.serviceMonitor) {
    window.serviceMonitor.usage.weatherCalls++;
  }
  const now = Date.now();
  
  // üî• CACHE INTELLIGENT - √âconomise 90% des appels API
  if (weatherCache.data && (now - weatherCache.timestamp) < weatherCache.duration) {
    console.log("üî• Donn√©es m√©t√©o depuis le cache");
    return weatherCache.data;
  }
  
  console.log("üîÑ R√©cup√©ration des donn√©es m√©t√©o directes...");
  
  try {
    const OPENWEATHER_API_KEY = '5b8c517e1582cb51d2ec1422e9c0b10d';
    
    const response = await fetch(
      `https://api.openweathermap.org/data/2.5/weather?q=Lille,fr&appid=${OPENWEATHER_API_KEY}&units=metric&lang=fr`
    );
    
    if (!response.ok) {
      throw new Error(`API m√©t√©o erreur: ${response.status}`);
    }
    
    const data = await response.json();
    
    // Traitement des donn√©es...
    const rainIds = [200, 201, 202, 230, 231, 232, 300, 301, 302, 310, 311, 312, 313, 314, 321, 500, 501, 502, 503, 504, 511, 520, 521, 522, 531];
    const isRainingById = data.weather.some(w => rainIds.includes(w.id));
    const hasRecentRain = data.rain && ((data.rain["1h"] || 0) > 0 || (data.rain["3h"] || 0) > 0);
    const isRaining = isRainingById || hasRecentRain;

    const temp = data.main.temp;
    let recommendation = "int√©rieur";
    
    if (!isRaining) {
      if (temp >= 18) {
        recommendation = "ext√©rieur";
      } else if (temp >= 14) {
        const isClearWeather = data.weather[0].id >= 800 && data.weather[0].id < 803;
        recommendation = isClearWeather ? "ext√©rieur" : "int√©rieur";
      }
    }

    const weatherData = {
      recommendation,
      temp: Math.round(temp * 10) / 10,
      humidity: data.main.humidity,
      raining: isRaining,
      city: data.name,
      weather: data.weather[0].description,
      success: true,
      realData: true
    };
    
    // üî• SAUVEGARDE DANS LE CACHE
    weatherCache = {
      data: weatherData,
      timestamp: now
    };
    
    console.log(`üéØ Recommandation: ${recommendation} (temp: ${temp}¬∞C, pluie: ${isRaining})`);
    return weatherData;
    
  } catch (error) {
    console.warn("‚ö†Ô∏è API m√©t√©o inaccessible:", error.message);
    
    // M√™me en erreur, on retourne le cache si disponible
    if (weatherCache.data) {
      console.log("üî• Retour au cache en cas d'erreur");
      return weatherCache.data;
    }
    
    return getSimulatedWeather();
  }
}

// Simulation r√©aliste bas√©e sur l'heure actuelle
function getSimulatedWeather() {
  const now = new Date();
  const hour = now.getHours();
  const month = now.getMonth();
  
  // Simulation r√©aliste pour Lille en cette saison
  let baseTemp;
  if (month >= 9 || month <= 2) { // Octobre √† Mars
    baseTemp = 8 + Math.random() * 8; // 8-16¬∞C r√©aliste pour Lille
  } else {
    baseTemp = 15 + Math.random() * 10;
  }
  
  // Variation selon l'heure
  if (hour >= 13 && hour <= 16) {
    baseTemp += 2; // Plus chaud l'apr√®s-midi
  } else if (hour >= 0 && hour <= 6) {
    baseTemp -= 3; // Plus froid la nuit
  }
  
  const temp = Math.round(baseTemp * 10) / 10;
  
  // Moins de chance de pluie (20%)
  const isRaining = Math.random() < 0.2;
  
  // LOGIQUE SIMUL√âE AM√âLIOR√âE
  let recommendation = "int√©rieur";
  if (!isRaining) {
    if (temp >= 16) {
      recommendation = "ext√©rieur";
    } else if (temp >= 13) {
      // Entre 13¬∞C et 16¬∞C, 50% de chance d'ext√©rieur
      recommendation = Math.random() > 0.5 ? "ext√©rieur" : "int√©rieur";
    }
  }
  
  const simulatedData = {
    recommendation,
    temp: temp,
    humidity: 70 + Math.floor(Math.random() * 20),
    raining: isRaining,
    simulated: true,
    city: "Lille",
    weather: isRaining ? "pluie l√©g√®re" : "partiellement nuageux"
  };
  
  console.log("üå§Ô∏è Donn√©es m√©t√©o simul√©es:", simulatedData);
  return simulatedData;
}

// DIAGNOSTIC COMPLET AVEC NOUVEAU BACKEND
// DIAGNOSTIC COMPLET AVEC NOUVEAU SYST√àME
async function diagnosticComplet() {
  console.log("üîç DIAGNOSTIC COMPLET - SYST√àME M√âT√âO DIRECT");
  
  // Test : Donn√©es finales
  console.log("1. Test des donn√©es m√©t√©o finales...");
  const weather = await getLilleWeather();
  
  console.log("üéØ R√©sultat final:");
  console.log(`   üìç Source: ${weather.realData ? '‚úÖ API R√©elle' : 'üîÑ Simulation'}`);
  console.log(`   üå°Ô∏è Temp√©rature: ${weather.temp}¬∞C`);
  console.log(`   ‚òîÔ∏è Pluie: ${weather.raining ? 'Oui ‚òîÔ∏è' : 'Non ‚òÄÔ∏è'}`);
  console.log(`   üéØ Recommandation: ${weather.recommendation}`);
  console.log(`   üìù Conditions: ${weather.weather}`);
  console.log(`   üíß Humidit√©: ${weather.humidity}%`);
}

// Lancez le diagnostic
setTimeout(diagnosticComplet, 1000);


function fermerStreetView() {
  const container = document.getElementById('streetview-embed-container');
  container.innerHTML = '';
  container.style.display = 'none';
}

// Configuration des recommandations
const recommendations = {
  lundi: {
    "00:00-06:00": ["G LA DALLE LILLE"],
    "06:00-06:30": ["L'Aziza (Rue Jules Guesde)", "Aux Pains Dor√©s"],
    "06:30-11:00": ["Aux Merveilleux de Fred", "L'Aziza (Rue Jules Guesde)", "Aux Pains Dor√©s"],
    "11:00-11:30": ["Snack Tetouan"],
    "11:30-14:00": ["Snack Tetouan", "Agadir Snack", "CHICKEN STREET NAAN AND FRIED CHICKEN LILLE"],
    "14:00-18:00": { 
      outdoor: [
        "Jardin des Plantes (Jardin botanique)",
        "Parc de la Citadelle",
        "Zoo de Lille"
      ],
      indoor: [
        "Westfield Euralille",
        "Zara Home",
        "Printemps Lille"
      ]
    },
    "18:00-00:00": ["Snack Tetouan", "Snack Mounir", "G LA DALLE LILLE"] 
  },
  mardi: {
    "00:00-06:00": ["G LA DALLE LILLE"],
    "06:00-07:00": ["Boulangerie Mathieu", "L'Aziza (Rue Jules Guesde)"],
    "07:00-11:00": ["L'Aziza (Place Nouvelle Aventure)", "Boulangerie Mathieu"],
    "11:00-11:30": ["Snack Tetouan"],
    "11:30-14:00": [
      "Snack Tetouan",
      "Snack Mounir",
      "Mangez Moi"
    ],
    "14:00-18:00": {  
      outdoor: [
        "Parc Jean-Baptiste Lebas",
        "Jardin des Plantes (Jardin botanique)",
        "Palais Rihour"
      ],
      indoor: [
        "Westfield Euralille",
        "Chic Nana",
        "Starship Laser Lille centre"
      ]
    },
    "18:00-00:00": ["Snack Tetouan", "Agadir Snack", "CHICKEN STREET NAAN AND FRIED CHICKEN LILLE"] 
  },
  mercredi: {
    "00:00-01:00": ["G LA DALLE LILLE", "CHICKEN STREET NAAN AND FRIED CHICKEN LILLE"],
    "01:00-06:00": ["G LA DALLE LILLE"],
    "06:00-07:00": ["Aux Pains Dor√©s", "Boulangerie Mathieu"],
    "07:00-11:00": ["Boulangerie Au p'tit Louis", "Aux Pains Dor√©s", "Boulangerie Mathieu"],
    "11:00-14:00": ["Snack Tetouan", "Agadir Snack", "Mangez Moi"],
    "14:00-18:00": {  
      outdoor: [
        "Parc de la Citadelle",
        "Jardin des Plantes (Jardin botanique)",
        "Parc Jean-Baptiste Lebas"
      ],
      indoor: [
        "Laser Game Evolution Lille Solf√©rino - Deux labyrinthes multiniveaux",
        "Westfield Euralille",
        "Starship Laser Lille centre"
      ]
    },
    "18:00-23:30": ["Snack Tetouan", "Snack Mounir", "Mangez Moi"],  
    "23:30-00:00": ["Snack Tetouan", "Snack Mounir", "CHICKEN STREET NAAN AND FRIED CHICKEN LILLE"]
  },
  jeudi: {
    "00:00-01:00": ["CHICKEN STREET NAAN AND FRIED CHICKEN LILLE", "G LA DALLE LILLE"],
    "01:00-06:00": ["G LA DALLE LILLE"],
    "06:00-06:30": ["Aux Pains Dor√©s", "L'Aziza (Rue Jules Guesde)"],
    "06:30-11:00": ["Aux Merveilleux de Fred", "L'Aziza (Rue Jules Guesde)"],
    "11:00-14:00": ["Snack Tetouan", "Agadir Snack"],
    "14:00-18:00": {  
      outdoor: [
        "Parc de la Citadelle",
        "Jardin des Plantes (Jardin botanique)",
        "Zoo de Lille"
      ],
      indoor: [
        "Westfield Euralille",
        "Zara Home",
        "Starship Laser Lille centre"
      ]
    },
    "18:00-23:30": ["Snack Tetouan", "Agadir Snack", "Mangez Moi"],  
    "23:30-00:00": ["Snack Tetouan", "Agadir Snack", "CHICKEN STREET NAAN AND FRIED CHICKEN LILLE"]
  },
  vendredi: {
    "00:00-01:00": ["CHICKEN STREET NAAN AND FRIED CHICKEN LILLE", "G LA DALLE LILLE"],
    "01:00-06:00": ["G LA DALLE LILLE"],
    "06:00-11:00": ["Boulangerie Mathieu", "Aux Pains Dor√©s", "L'Aziza (Rue Jules Guesde)"],
    "11:00-11:30": ["Snack Tetouan"],
    "11:30-14:00": [
      "Snack Tetouan",
      "Snack Mounir",
      "Mangez Moi"
    ],
    "14:00-18:00": {  
      outdoor: [
        "Parc de la Citadelle",
        "Jardin des Plantes (Jardin botanique)",
        "Zoo de Lille"
      ],
      indoor: [
        "Westfield Euralille",
        "Zara Home",
        "Starship Laser Lille centre"
      ]
    },
    "18:00-00:00": ["Snack Tetouan", "Agadir Snack", "CHICKEN STREET NAAN AND FRIED CHICKEN LILLE"]  
  },
  samedi: {
    "00:00-01:00": ["CHICKEN STREET NAAN AND FRIED CHICKEN LILLE", "Mangez Moi"],
    "01:00-06:00": ["G LA DALLE LILLE"],
    "06:00-06:30": ["Boulangerie Mathieu", "L'Aziza (Rue Jules Guesde)"],
    "06:30-11:30": ["Aux Merveilleux de Fred", "Boulangerie Mathieu", "L'Aziza (Rue Jules Guesde)"],
    "11:30-12:00": ["Snack Tetouan", "Agadir Snack", "CHICKEN STREET NAAN AND FRIED CHICKEN LILLE"],
    "12:00-14:00": ["Snack Mounir", "Mangez Moi", "Snack Tetouan"],
    "14:00-18:00": {  
      outdoor: [
        "Jardin des Plantes (Jardin botanique)",
        "Zoo de Lille",
        "Parc de la Citadelle"
      ],
      indoor: [
        "Laser Game Evolution Lille Solf√©rino - Deux labyrinthes multiniveaux",
        "Westfield Euralille",
        "Starship Laser Lille centre"
      ]
    },
    "18:00-23:00": ["Snack Tetouan", "Agadir Snack", "Mangez Moi", "CHICKEN STREET NAAN AND FRIED CHICKEN LILLE"]  
  },
  dimanche: {
    "00:00-02:00": ["Snack Tetouan", "CHICKEN STREET NAAN AND FRIED CHICKEN LILLE", "G LA DALLE LILLE"],
    "02:00-06:00": ["G LA DALLE LILLE"],
    "06:00-06:30": ["Boulangerie Mathieu", "L'Aziza (Rue Jules Guesde)"],
    "06:30-11:30": ["L'Aziza (Rue Jules Guesde)", "Aux Merveilleux de Fred"],
    "11:30-14:00": ["Mangez Moi", "Snack Tetouan", "Agadir Snack"],
    "14:00-18:00": {  // Chang√© de 18h √† 19h
      outdoor: [
        "Jardin des Plantes",
        "Zoo de Lille",
        "Jardin Vauban"
      ],
      indoor: [
        "Maison M√©ert",
        "Laser Game Evolution Lille Solf√©rino - Deux labyrinthes multiniveauxe",
        "Starship Laser Lille centre"
      ]
    },
    "18:00-00:00": ["Snack Tetouan", "Mangez Moi", "G LA DALLE LILLE"]  // Chang√© de 18h √† 19h
  }
};



 // Fonction pour d√©terminer la tranche horaire actuelle
 

    // Fonction pour obtenir le jour en fran√ßais
function getFrenchDay() {
  const days = ['dimanche', 'lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi'];
  return days[new Date().getDay()];
}

// Fonction pour d√©terminer la tranche horaire actuelle
function getCurrentTimeSlotDynamic(day) {
  const now = new Date();
  const totalMinutes = now.getHours() * 60 + now.getMinutes();

  // R√©cup√©rer les plages horaires du jour (ex: "00:00-01:00", "01:00-06:00", etc.)
  const slots = Object.keys(recommendations[day]);

  for (const slot of slots) {
    // D√©couper la plage en d√©but et fin
    const [startStr, endStr] = slot.split('-');
    
    // Convertir heures en minutes depuis minuit
    const startParts = startStr.split(':');
    const endParts = endStr.split(':');

    const startMinutes = parseInt(startParts[0]) * 60 + parseInt(startParts[1]);
    let endMinutes = parseInt(endParts[0]) * 60 + parseInt(endParts[1]);

    // G√©rer le cas o√π la fin est "00:00" (donc minuit suivant)
    if (endMinutes === 0) endMinutes = 24 * 60;

    // V√©rifier si totalMinutes est dans cette plage
    if (totalMinutes >= startMinutes && totalMinutes < endMinutes) {
      return slot;
    }
  }

  // Si aucune plage trouv√©e (peu probable), retourner la premi√®re
  return slots[0];
}

// Fonction simul√©e pour afficher sur la carte (√† adapter selon ton code)
function afficherSurCarte(serviceName) {
  console.log("Afficher sur la carte :", serviceName);
  // Ajoute ici ta logique pour afficher le service sur la carte
}

 // Fonction pour trouver un service par son nom
    function trouverServiceParNom(nom) {
      if (!allFeatures) return null;
      
      for (const feature of allFeatures) {
        const props = feature.properties;
        if (props.name && props.name.toLowerCase() === nom.toLowerCase()) {
          return {
            name: props.name,
            lat: feature.geometry.coordinates[1],
            lng: feature.geometry.coordinates[0]
          };
        }
      }
      return null;
    }

    function centrerSurService(nom) {
  const service = trouverServiceParNom(nom);
  if (!service) return;

  const decaleLat = service.lat - 0.0022;
  const targetLatLng = L.latLng(service.lat, service.lng);

  map.flyTo([decaleLat, service.lng], 17, {
    animate: true,
    duration: 1
  });

  setTimeout(() => {
    let markerTrouve = null;

    clusterLayer.eachLayer(marker => {
      if (!marker.getLatLng) return;

      const distance = map.distance(marker.getLatLng(), targetLatLng);
      const popupContent = marker.getPopup()?.getContent() || '';
      const nomDansPopup = popupContent.match(/<b>(.*?)<\/b>/)?.[1];
      
      if (distance < 10 && nomDansPopup === nom) {
        markerTrouve = marker;
      }
    });

    if (markerTrouve) {
      clusterLayer.zoomToShowLayer(markerTrouve, () => {
        map.closePopup();
        setTimeout(() => {
          markerTrouve.openPopup();
        }, 100);
      });
    }
  }, 1100);
}


    
    // Fonction pour obtenir les services selon la m√©t√©o
async function getServicesForTimeSlot() {
  const day = getFrenchDay();
  const timeSlot = getCurrentTimeSlotDynamic(day);
  const slotData = recommendations[day][timeSlot];
  
  // V√©rifie si c'est une plage horaire avec choix indoor/outdoor
  if (typeof slotData === 'object' && !Array.isArray(slotData)) {
    const weather = await getLilleWeather();
    return weather.raining ? slotData.indoor : slotData.outdoor;
  }
  
  return slotData;
}
    
    // Fonction pour afficher les recommandations
    function getTitreRecommandation() {
      const now = new Date();
      const hours = now.getHours();
      
      if (hours >= 6 && hours < 11) {
        return "Petit d√©jeuner";
      } else if (hours >= 11 && hours < 14) {
        return "O√π d√©jeuner";
      } else if (hours >= 14 && hours < 18) {
        return "Activit√©s √† Lille";
      } else if (hours >= 18 || hours < 0) {
        return "O√π d√Æner ce soir";
      } else if (hours >= 0 || hours < 6) {
        return "Petite collation nocturne?";
      }
      return "Recommandations du moment"; // Par d√©faut
    }
    
    // Fonction pour v√©rifier si c'est un jour de march√©
    function isMarketDay() {
      const day = new Date().getDay(); // 0 = dimanche, 1 = lundi, etc.
      // Les jours de march√© sont mardi, jeudi et dimanche
      return day === 0 || day === 2 || day === 4; // Dimanche, Mardi, Jeudi
    }
    // Fonction pour v√©rifier si l'heure est entre 6h et 11h
    function isMarketTime() {
      const now = new Date();
      const hour = now.getHours();
      return hour >= 6 && hour < 14;
    }


    // Fonction pour obtenir les recommandations adapt√©es √† la m√©t√©o
async function getWeatherAdjustedRecommendations(day, timeSlot) {
  const weather = await getLilleWeather();
  const isCold = weather.temp < 10; // On consid√®re "froid" en dessous de 10¬∞C
  const isRaining = weather.raining;
  
  // Si chaud et pas de pluie: activit√©s ext√©rieur
  if (!isCold && !isRaining) {
    return recommendations[day][timeSlot]?.outdoor || [];
  }
  // Si froid ou pluie: activit√©s int√©rieur
  else {
    return recommendations[day][timeSlot]?.indoor || [];
  }
}

async function afficherRecommandations() {
  const day = getFrenchDay(); // ex: "lundi"
  const slot = getCurrentTimeSlotDynamic(day); // ex: "14:00-18:00"

  const reco = recommendations[day][slot];

  // Cas sp√©cial : si la recommandation a "outdoor" et "indoor"
  if (typeof reco === 'object' && reco.outdoor && reco.indoor) {
    const meteo = await getLilleWeather(); // Obtenir la m√©t√©o

    const lieux = meteo.raining ? reco.indoor : reco.outdoor; // Choisir selon m√©t√©o

    console.log(`üìç M√©t√©o √† Lille : ${meteo.raining ? "Pluie ‚òîÔ∏è" : "Pas de pluie ‚òÄÔ∏è"}`);
    console.log(`üëâ Lieux recommand√©s (${meteo.raining ? "indoor" : "outdoor"}) :`, lieux);

    lieux.forEach(nom => afficherSurCarte(nom)); // Afficher sur la carte
  }
  // Cas normal (pas de indoor/outdoor, juste une liste)
  else if (Array.isArray(reco)) {
    reco.forEach(nom => afficherSurCarte(nom));
  }
}

    function showRecommendations() {
  const container = document.getElementById('recommandation-container');
  const titleElem = document.getElementById('recommandation-title');
  const serviceElem = document.getElementById('recommandation-service');
  const timeElem = document.getElementById('recommandation-time');
  
  titleElem.textContent = getTitreRecommandation();
  
  if (!allFeatures || allFeatures.length === 0) {
    serviceElem.innerHTML = "<div style='text-align:center; padding:10px;'>Chargement des donn√©es...</div>";
    return;
  }
  
  serviceElem.innerHTML = `
    <div class="loading-dots">
      <div class="dot"></div>
      <div class="dot"></div>
      <div class="dot"></div>
    </div>
  `;
  
  // Transformation en fonction asynchrone pour g√©rer la m√©t√©o
  setTimeout(async () => {
    const day = getFrenchDay();
    const timeSlot = getCurrentTimeSlotDynamic(day);
    
    let slotRecommendations = [];
    let weatherInfo = "";

    // Modification uniquement pour le cr√©neau 14h-18h
    if (timeSlot === "14:00-18:00") {
      try {
        const weather = await getLilleWeather();
        
        // Afficher l'info m√©t√©o dans le titre
        weatherInfo = ` (${weather.temp}¬∞C${weather.raining ? ' ‚òîÔ∏è Activit√©s couvertes' : weather.recommendation === 'ext√©rieur' ? ' ‚òÄÔ∏è Activit√©s ext√©rieures' : ' üè† Activit√©s int√©rieures'})`;
        
        // Utiliser directement la recommandation du serveur
        if (weather.recommendation === "ext√©rieur") {
          slotRecommendations = recommendations[day][timeSlot].outdoor || [];
        } else {
          slotRecommendations = recommendations[day][timeSlot].indoor || [];
        }
        
        console.log(`üìç M√©t√©o Lille: ${weather.temp}¬∞C, ${weather.raining ? 'Pluie' : 'Pas de pluie'}, Recommandation: ${weather.recommendation}`);
        
      } catch (error) {
        console.error("Erreur m√©t√©o:", error);
        slotRecommendations = recommendations[day][timeSlot]?.outdoor || [];
        weatherInfo = " (üå§Ô∏è)";
      }
    }
    // Comportement normal pour les autres cr√©neaux
    else if (recommendations[day] && recommendations[day][timeSlot]) {
      slotRecommendations = recommendations[day][timeSlot];
    }
    
    const validRecommendations = slotRecommendations.filter(nom => trouverServiceParNom(nom));
    
    // Mettre √† jour le titre avec les infos m√©t√©o
    if (weatherInfo) {
      titleElem.textContent = getTitreRecommandation() + weatherInfo;
    }
    
    if (validRecommendations.length === 0) {
      serviceElem.innerHTML = "<div style='text-align:center; padding:10px;'>Aucune recommandation valide</div>";
    } else {
      const listHtml = validRecommendations
  .map(rec => `<li data-service="${rec}">${rec}</li>`)
  .join('');

serviceElem.innerHTML = `<ul>${listHtml}</ul>`;

const items = serviceElem.querySelectorAll('li');
items.forEach(item => {
  item.addEventListener('click', () => {
    const serviceName = item.getAttribute('data-service');
    console.log("üéØ Clic recommandation:", serviceName);
    centrerSurService(serviceName);
  });
});
    }
    
    const now = new Date();
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    timeElem.textContent = `Mis √† jour √† ${hours}:${minutes}`;
  }, 1000);
  
  // Gestion du carr√© suppl√©mentaire pour les march√©s (inchang√©)
  const marketContainer = document.getElementById('market-container');
  const marketTitle = document.getElementById('market-title');
  const marketService = document.getElementById('market-service');
  const isMarket = isMarketDay() && isMarketTime();
  
  if (isMarket) {
    marketContainer.style.display = 'block';
    marketTitle.textContent = "Jour de march√©!";
    marketService.innerHTML = `
      <ul>
        <li>March√© de Wazemmes</li>
        <li>March√© de Mons-en-Bar≈ìul</li>
      </ul>
    `;
    
    document.querySelectorAll('#market-service li').forEach(item => {
      item.addEventListener('click', () => {
        centrerSurService(item.textContent);
      });
    });
  } else {
    marketContainer.style.display = 'none';
  }
  
  showJumuaMosques();
}
    
    // Fermer le carr√© de recommandation
    function fermerRecommandation() {
      document.getElementById('recommandation-container').style.display = 'none';
    }
    
    // Dans le code de chargement des donn√©es
    fetch('yi.geojson')
      .then(res => res.json())
      .then(data => {
        allFeatures = data.features;
        afficherServices("");
        
        // Afficher les recommandations apr√®s le chargement des donn√©es
        showRecommendations();
      }) 
      .catch(error => {
        console.error("Erreur de chargement des donn√©es:", error);
      });

    // Rafra√Æchir les recommandations toutes les 10 minutes
    setInterval(showRecommendations, 10 * 60 * 1000);
    // Fonction pour obtenir le titre en fonction de l'heure
    
    // Fonction pour v√©rifier si c'est vendredi entre 11h et 14h
function isJumuaTime() {
  const now = new Date();
  const day = now.getDay(); // 0 = dimanche, 5 = vendredi
  const hour = now.getHours();
  
  return day === 5 && hour >= 10 && hour < 14;
}

// Fonction pour afficher les mosqu√©es pour Jumua
function showJumuaMosques() {
  const container = document.getElementById('jumua-container');
  const serviceElem = document.getElementById('jumua-service');
  
  if (isJumuaTime()) {
    container.style.display = 'block';
    serviceElem.innerHTML = `
      <ul style="list-style: none; padding-left: 0; margin: 0;">
        <li style="padding: 8px; border-radius: 6px; margin-bottom: 8px; background: #f0f8ff; border-left: 4px solid #4CAF50; cursor: pointer;">Grande Mosqu√©e de Mons-en-Baroeul</li>
        <li style="padding: 8px; border-radius: 6px; margin-bottom: 8px; background: #f0f8ff; border-left: 4px solid #4CAF50; cursor: pointer;">Mosqu√©e Badr</li>
        <li style="padding: 8px; border-radius: 6px; margin-bottom: 8px; background: #f0f8ff; border-left: 4px solid #4CAF50; cursor: pointer;">Mosqu√©e El Forkane</li>
      </ul>
    `;
    
    // Ajouter les √©v√©nements clic
    document.querySelectorAll('#jumua-service li').forEach((item, index) => {
      item.addEventListener('click', () => {
        const mosques = [
          "Grande Mosqu√©e de Mons-en-Baroeul (Mosqu√©e Al Wifaq)",
          "Mosqu√©e Badr",
          "Mosqu√©e El Forkane"
        ];
        centrerSurService(mosques[index]);
      });
    });
  } else {
    container.style.display = 'none';
  }
}

// Appeler cette fonction au chargement et p√©riodiquement
showJumuaMosques();
setInterval(showJumuaMosques, 60000); // V√©rifier chaque minute
// Ajoutez cette fonction dans votre script
function checkLocation() {
  // Coordonn√©es approximatives de Lille
  const lilleCenter = [50.6292, 3.0573];
  const lilleRadius = 15; // Rayon en kilom√®tres

  if (!userLocation) return;

  const distance = calculateDistance(
    userLocation[0], 
    userLocation[1],
    lilleCenter[0],
    lilleCenter[1]
  );

  if (distance > lilleRadius) {
    document.getElementById('warningBanner').classList.remove('hidden');
  }
}

// Fonction utilitaire pour calculer la distance
function calculateDistance(lat1, lon1, lat2, lon2) {
  const R = 6371; // Rayon de la terre en km
  const dLat = deg2rad(lat2 - lat1);
  const dLon = deg2rad(lon2 - lon1);
  const a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * 
    Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
  return R * c; // Distance en km
}

function deg2rad(deg) {
  return deg * (Math.PI/180);
}

function hideWarning() {
  const banner = document.getElementById('warningBanner');
  banner.classList.add('hidden');
  setTimeout(() => { banner.style.display = 'none'; }, 350);
}
// Fonction de test pour v√©rifier les donn√©es m√©t√©o
async function testMeteo() {
  console.log("üß™ Test des donn√©es m√©t√©o...");
  const weather = await getLilleWeather();
  console.log("‚úÖ Donn√©es m√©t√©o:", weather);
  
  if (weather.recommendation) {
    console.log(`üéØ Recommandation: ${weather.recommendation}`);
    console.log(`üå°Ô∏è Temp√©rature: ${weather.temp}¬∞C`);
    console.log(`‚òîÔ∏è Pluie: ${weather.raining ? 'Oui' : 'Non'}`);
  }
}

// Appeler au chargement pour tester
document.addEventListener('DOMContentLoaded', function() {
  setTimeout(testMeteo, 2000);
});

// Appeler cette fonction apr√®s avoir obtenu la position utilisateur
// Dans votre fonction de g√©olocalisation existante, apr√®s avoir d√©fini userLocation:
checkLocation();
  </script>
  <!-- Modal QR Code -->
<div id="qr-modal" class="modal">
  <div class="modal-content" style="text-align: center; max-width: 300px;">
    <span class="close-btn" onclick="fermerQRModal()">&times;</span>
    <h2>Partager ce lieu</h2>
    <div id="qr-code-container"></div>
    <p id="lien-partage" style="word-break: break-all; margin: 15px 0;"></p>
    <button onclick="telechargerQRCode()">T√©l√©charger le QR Code</button>
    <button onclick="copierLienPartage()">Copier le lien</button>
  </div>
</div>
<script defer src="/_vercel/insights/script.js"></script>

</body>
</html>